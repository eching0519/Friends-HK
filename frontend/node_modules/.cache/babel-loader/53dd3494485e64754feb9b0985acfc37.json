{"ast":null,"code":"import jquery from 'jquery';\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css = \"/*!Ion.RangeSlider, 2.3.1, © Denis Ineshin, 2010 - 2019, IonDen.com, Build date: 2019-12-19 16:51:02*/.irs{position:relative;display:block;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;font-size:12px;font-family:Arial,sans-serif}.irs-line{position:relative;display:block;overflow:hidden;outline:none !important}.irs-bar{position:absolute;display:block;left:0;width:0}.irs-shadow{position:absolute;display:none;left:0;width:0}.irs-handle{position:absolute;display:block;box-sizing:border-box;cursor:default;z-index:1}.irs-handle.type_last{z-index:2}.irs-min,.irs-max{position:absolute;display:block;cursor:default}.irs-min{left:0}.irs-max{right:0}.irs-from,.irs-to,.irs-single{position:absolute;display:block;top:0;left:0;cursor:default;white-space:nowrap}.irs-grid{position:absolute;display:none;bottom:0;left:0;width:100%;height:20px}.irs-with-grid .irs-grid{display:block}.irs-grid-pol{position:absolute;top:0;left:0;width:1px;height:8px;background:#000}.irs-grid-pol.small{height:4px}.irs-grid-text{position:absolute;bottom:0;left:0;white-space:nowrap;text-align:center;font-size:9px;line-height:9px;padding:0 3px;color:#000}.irs-disable-mask{position:absolute;display:block;top:0;left:-1%;width:102%;height:100%;cursor:default;background:rgba(0,0,0,0);z-index:2}.lt-ie9 .irs-disable-mask{background:#000;filter:alpha(opacity=0);cursor:not-allowed}.irs-disabled{opacity:.4}.irs-hidden-input{position:absolute !important;display:block !important;top:0 !important;left:0 !important;width:0 !important;height:0 !important;font-size:0 !important;line-height:0 !important;padding:0 !important;margin:0 !important;overflow:hidden;outline:none !important;z-index:-9999 !important;background:none !important;border-style:solid !important;border-color:transparent !important}.irs--flat{height:40px}.irs--flat.irs-with-grid{height:60px}.irs--flat .irs-line{top:25px;height:12px;background-color:#e1e4e9;border-radius:4px}.irs--flat .irs-bar{top:25px;height:12px;background-color:#ed5565}.irs--flat .irs-bar--single{border-radius:4px 0 0 4px}.irs--flat .irs-shadow{height:1px;bottom:16px;background-color:#e1e4e9}.irs--flat .irs-handle{top:22px;width:16px;height:18px;background-color:transparent}.irs--flat .irs-handle>i:first-child{position:absolute;display:block;top:0;left:50%;width:2px;height:100%;margin-left:-1px;background-color:#da4453}.irs--flat .irs-handle.state_hover>i:first-child,.irs--flat .irs-handle:hover>i:first-child{background-color:#a43540}.irs--flat .irs-min,.irs--flat .irs-max{top:0;padding:1px 3px;color:#999;font-size:10px;line-height:1.333;text-shadow:none;background-color:#e1e4e9;border-radius:4px}.irs--flat .irs-from,.irs--flat .irs-to,.irs--flat .irs-single{color:white;font-size:10px;line-height:1.333;text-shadow:none;padding:1px 5px;background-color:#ed5565;border-radius:4px}.irs--flat .irs-from:before,.irs--flat .irs-to:before,.irs--flat .irs-single:before{position:absolute;display:block;content:\\\"\\\";bottom:-6px;left:50%;width:0;height:0;margin-left:-3px;overflow:hidden;border:3px solid transparent;border-top-color:#ed5565}.irs--flat .irs-grid-pol{background-color:#e1e4e9}.irs--flat .irs-grid-text{color:#999}.irs--big{height:55px}.irs--big.irs-with-grid{height:70px}.irs--big .irs-line{top:33px;height:12px;background-color:white;background:linear-gradient(to bottom, #ddd -50%, white 150%);border:1px solid #ccc;border-radius:12px}.irs--big .irs-bar{top:33px;height:12px;background-color:#92bce0;border:1px solid #428bca;background:linear-gradient(to bottom, #ffffff 0%, #428bca 30%, #b9d4ec 100%);box-shadow:inset 0 0 1px 1px rgba(255,255,255,0.5)}.irs--big .irs-bar--single{border-radius:12px 0 0 12px}.irs--big .irs-shadow{height:1px;bottom:16px;background-color:rgba(66,139,202,0.5)}.irs--big .irs-handle{top:25px;width:30px;height:30px;border:1px solid rgba(0,0,0,0.3);background-color:#cbcfd5;background:linear-gradient(to bottom, white 0%, #B4B9BE 30%, white 100%);box-shadow:1px 1px 2px rgba(0,0,0,0.2),inset 0 0 3px 1px white;border-radius:30px}.irs--big .irs-handle.state_hover,.irs--big .irs-handle:hover{border-color:rgba(0,0,0,0.45);background-color:#939ba7;background:linear-gradient(to bottom, white 0%, #919BA5 30%, white 100%)}.irs--big .irs-min,.irs--big .irs-max{top:0;padding:1px 5px;color:white;text-shadow:none;background-color:#9f9f9f;border-radius:3px}.irs--big .irs-from,.irs--big .irs-to,.irs--big .irs-single{color:white;text-shadow:none;padding:1px 5px;background-color:#428bca;background:linear-gradient(to bottom, #428bca 0%, #3071a9 100%);border-radius:3px}.irs--big .irs-grid-pol{background-color:#428bca}.irs--big .irs-grid-text{color:#428bca}.irs--modern{height:55px}.irs--modern.irs-with-grid{height:55px}.irs--modern .irs-line{top:25px;height:5px;background-color:#d1d6e0;background:linear-gradient(to bottom, #e0e4ea 0%, #d1d6e0 100%);border:1px solid #a3adc1;border-bottom-width:0;border-radius:5px}.irs--modern .irs-bar{top:25px;height:5px;background:#20b426;background:linear-gradient(to bottom, #20b426 0%, #18891d 100%)}.irs--modern .irs-bar--single{border-radius:5px 0 0 5px}.irs--modern .irs-shadow{height:1px;bottom:21px;background-color:rgba(209,214,224,0.5)}.irs--modern .irs-handle{top:37px;width:12px;height:13px;border:1px solid #a3adc1;border-top-width:0;box-shadow:1px 1px 1px rgba(0,0,0,0.1);border-radius:0 0 3px 3px}.irs--modern .irs-handle>i:nth-child(1){position:absolute;display:block;top:-4px;left:1px;width:6px;height:6px;border:1px solid #a3adc1;background:white;transform:rotate(45deg)}.irs--modern .irs-handle>i:nth-child(2){position:absolute;display:block;box-sizing:border-box;top:0;left:0;width:10px;height:12px;background:#e9e6e6;background:linear-gradient(to bottom, white 0%, #e9e6e6 100%);border-radius:0 0 3px 3px}.irs--modern .irs-handle>i:nth-child(3){position:absolute;display:block;box-sizing:border-box;top:3px;left:3px;width:4px;height:5px;border-left:1px solid #a3adc1;border-right:1px solid #a3adc1}.irs--modern .irs-handle.state_hover,.irs--modern .irs-handle:hover{border-color:#7685a2;background:#c3c7cd;background:linear-gradient(to bottom, #ffffff 0%, #919ba5 30%, #ffffff 100%)}.irs--modern .irs-handle.state_hover>i:nth-child(1),.irs--modern .irs-handle:hover>i:nth-child(1){border-color:#7685a2}.irs--modern .irs-handle.state_hover>i:nth-child(3),.irs--modern .irs-handle:hover>i:nth-child(3){border-color:#48536a}.irs--modern .irs-min,.irs--modern .irs-max{top:0;font-size:10px;line-height:1.333;text-shadow:none;padding:1px 5px;color:white;background-color:#d1d6e0;border-radius:5px}.irs--modern .irs-from,.irs--modern .irs-to,.irs--modern .irs-single{font-size:10px;line-height:1.333;text-shadow:none;padding:1px 5px;background-color:#20b426;color:white;border-radius:5px}.irs--modern .irs-from:before,.irs--modern .irs-to:before,.irs--modern .irs-single:before{position:absolute;display:block;content:\\\"\\\";bottom:-6px;left:50%;width:0;height:0;margin-left:-3px;overflow:hidden;border:3px solid transparent;border-top-color:#20b426}.irs--modern .irs-grid{height:25px}.irs--modern .irs-grid-pol{background-color:#dedede}.irs--modern .irs-grid-text{color:silver;font-size:13px}.irs--sharp{height:50px;font-size:12px;line-height:1}.irs--sharp.irs-with-grid{height:57px}.irs--sharp .irs-line{top:30px;height:2px;background-color:black;border-radius:2px}.irs--sharp .irs-bar{top:30px;height:2px;background-color:#ee22fa}.irs--sharp .irs-bar--single{border-radius:2px 0 0 2px}.irs--sharp .irs-shadow{height:1px;bottom:21px;background-color:rgba(0,0,0,0.5)}.irs--sharp .irs-handle{top:25px;width:10px;height:10px;background-color:#a804b2}.irs--sharp .irs-handle>i:first-child{position:absolute;display:block;top:100%;left:0;width:0;height:0;border:5px solid transparent;border-top-color:#a804b2}.irs--sharp .irs-handle.state_hover,.irs--sharp .irs-handle:hover{background-color:black}.irs--sharp .irs-handle.state_hover>i:first-child,.irs--sharp .irs-handle:hover>i:first-child{border-top-color:black}.irs--sharp .irs-min,.irs--sharp .irs-max{color:white;font-size:14px;line-height:1;top:0;padding:3px 4px;opacity:.4;background-color:#a804b2;border-radius:2px}.irs--sharp .irs-from,.irs--sharp .irs-to,.irs--sharp .irs-single{font-size:14px;line-height:1;text-shadow:none;padding:3px 4px;background-color:#a804b2;color:white;border-radius:2px}.irs--sharp .irs-from:before,.irs--sharp .irs-to:before,.irs--sharp .irs-single:before{position:absolute;display:block;content:\\\"\\\";bottom:-6px;left:50%;width:0;height:0;margin-left:-3px;overflow:hidden;border:3px solid transparent;border-top-color:#a804b2}.irs--sharp .irs-grid{height:25px}.irs--sharp .irs-grid-pol{background-color:#dedede}.irs--sharp .irs-grid-text{color:silver;font-size:13px}.irs--round{height:50px}.irs--round.irs-with-grid{height:65px}.irs--round .irs-line{top:36px;height:4px;background-color:#dee4ec;border-radius:4px}.irs--round .irs-bar{top:36px;height:4px;background-color:#006cfa}.irs--round .irs-bar--single{border-radius:4px 0 0 4px}.irs--round .irs-shadow{height:4px;bottom:21px;background-color:rgba(222,228,236,0.5)}.irs--round .irs-handle{top:26px;width:24px;height:24px;border:4px solid #006cfa;background-color:white;border-radius:24px;box-shadow:0 1px 3px rgba(0,0,255,0.3)}.irs--round .irs-handle.state_hover,.irs--round .irs-handle:hover{background-color:#f0f6ff}.irs--round .irs-min,.irs--round .irs-max{color:#333;font-size:14px;line-height:1;top:0;padding:3px 5px;background-color:rgba(0,0,0,0.1);border-radius:4px}.irs--round .irs-from,.irs--round .irs-to,.irs--round .irs-single{font-size:14px;line-height:1;text-shadow:none;padding:3px 5px;background-color:#006cfa;color:white;border-radius:4px}.irs--round .irs-from:before,.irs--round .irs-to:before,.irs--round .irs-single:before{position:absolute;display:block;content:\\\"\\\";bottom:-6px;left:50%;width:0;height:0;margin-left:-3px;overflow:hidden;border:3px solid transparent;border-top-color:#006cfa}.irs--round .irs-grid{height:25px}.irs--round .irs-grid-pol{background-color:#dedede}.irs--round .irs-grid-text{color:silver;font-size:13px}.irs--square{height:50px}.irs--square.irs-with-grid{height:60px}.irs--square .irs-line{top:31px;height:4px;background-color:#dedede}.irs--square .irs-bar{top:31px;height:4px;background-color:black}.irs--square .irs-shadow{height:2px;bottom:21px;background-color:#dedede}.irs--square .irs-handle{top:25px;width:16px;height:16px;border:3px solid black;background-color:white;-webkit-transform:rotate(45deg);-ms-transform:rotate(45deg);transform:rotate(45deg)}.irs--square .irs-handle.state_hover,.irs--square .irs-handle:hover{background-color:#f0f6ff}.irs--square .irs-min,.irs--square .irs-max{color:#333;font-size:14px;line-height:1;top:0;padding:3px 5px;background-color:rgba(0,0,0,0.1)}.irs--square .irs-from,.irs--square .irs-to,.irs--square .irs-single{font-size:14px;line-height:1;text-shadow:none;padding:3px 5px;background-color:black;color:white}.irs--square .irs-grid{height:25px}.irs--square .irs-grid-pol{background-color:#dedede}.irs--square .irs-grid-text{color:silver;font-size:11px}\";\nstyleInject(css);\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar ion_rangeSlider = createCommonjsModule(function (module, exports) {\n  (function (factory) {\n    if ((typeof jQuery === 'undefined' || !jQuery) && typeof undefined === \"function\" && undefined.amd) {\n      undefined([\"jquery\"], function (jQuery) {\n        return factory(jQuery, document, window, navigator);\n      });\n    } else if ((typeof jQuery === 'undefined' || !jQuery) && 'object' === \"object\") {\n      factory(jquery, document, window, navigator);\n    } else {\n      factory(jQuery, document, window, navigator);\n    }\n  })(function ($, document, window, navigator, undefined) {\n    // =================================================================================================================\n    // Service\n    var plugin_count = 0; // IE8 fix\n\n    var is_old_ie = function () {\n      var n = navigator.userAgent,\n          r = /msie\\s\\d+/i,\n          v;\n\n      if (n.search(r) > 0) {\n        v = r.exec(n).toString();\n        v = v.split(\" \")[1];\n\n        if (v < 9) {\n          $(\"html\").addClass(\"lt-ie9\");\n          return true;\n        }\n      }\n\n      return false;\n    }();\n\n    if (!Function.prototype.bind) {\n      Function.prototype.bind = function bind(that) {\n        var target = this;\n        var slice = [].slice;\n\n        if (typeof target != \"function\") {\n          throw new TypeError();\n        }\n\n        var args = slice.call(arguments, 1),\n            bound = function () {\n          if (this instanceof bound) {\n            var F = function () {};\n\n            F.prototype = target.prototype;\n            var self = new F();\n            var result = target.apply(self, args.concat(slice.call(arguments)));\n\n            if (Object(result) === result) {\n              return result;\n            }\n\n            return self;\n          } else {\n            return target.apply(that, args.concat(slice.call(arguments)));\n          }\n        };\n\n        return bound;\n      };\n    }\n\n    if (!Array.prototype.indexOf) {\n      Array.prototype.indexOf = function (searchElement, fromIndex) {\n        var k;\n\n        if (this == null) {\n          throw new TypeError('\"this\" is null or not defined');\n        }\n\n        var O = Object(this);\n        var len = O.length >>> 0;\n\n        if (len === 0) {\n          return -1;\n        }\n\n        var n = +fromIndex || 0;\n\n        if (Math.abs(n) === Infinity) {\n          n = 0;\n        }\n\n        if (n >= len) {\n          return -1;\n        }\n\n        k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n\n        while (k < len) {\n          if (k in O && O[k] === searchElement) {\n            return k;\n          }\n\n          k++;\n        }\n\n        return -1;\n      };\n    } // =================================================================================================================\n    // Template\n\n\n    var base_html = '<span class=\"irs\">' + '<span class=\"irs-line\" tabindex=\"0\"></span>' + '<span class=\"irs-min\">0</span><span class=\"irs-max\">1</span>' + '<span class=\"irs-from\">0</span><span class=\"irs-to\">0</span><span class=\"irs-single\">0</span>' + '</span>' + '<span class=\"irs-grid\"></span>';\n    var single_html = '<span class=\"irs-bar irs-bar--single\"></span>' + '<span class=\"irs-shadow shadow-single\"></span>' + '<span class=\"irs-handle single\"><i></i><i></i><i></i></span>';\n    var double_html = '<span class=\"irs-bar\"></span>' + '<span class=\"irs-shadow shadow-from\"></span>' + '<span class=\"irs-shadow shadow-to\"></span>' + '<span class=\"irs-handle from\"><i></i><i></i><i></i></span>' + '<span class=\"irs-handle to\"><i></i><i></i><i></i></span>';\n    var disable_html = '<span class=\"irs-disable-mask\"></span>'; // =================================================================================================================\n    // Core\n\n    /**\r\n     * Main plugin constructor\r\n     *\r\n     * @param input {Object} link to base input element\r\n     * @param options {Object} slider config\r\n     * @param plugin_count {Number}\r\n     * @constructor\r\n     */\n\n    var IonRangeSlider = function (input, options, plugin_count) {\n      this.VERSION = \"2.3.1\";\n      this.input = input;\n      this.plugin_count = plugin_count;\n      this.current_plugin = 0;\n      this.calc_count = 0;\n      this.update_tm = 0;\n      this.old_from = 0;\n      this.old_to = 0;\n      this.old_min_interval = null;\n      this.raf_id = null;\n      this.dragging = false;\n      this.force_redraw = false;\n      this.no_diapason = false;\n      this.has_tab_index = true;\n      this.is_key = false;\n      this.is_update = false;\n      this.is_start = true;\n      this.is_finish = false;\n      this.is_active = false;\n      this.is_resize = false;\n      this.is_click = false;\n      options = options || {}; // cache for links to all DOM elements\n\n      this.$cache = {\n        win: $(window),\n        body: $(document.body),\n        input: $(input),\n        cont: null,\n        rs: null,\n        min: null,\n        max: null,\n        from: null,\n        to: null,\n        single: null,\n        bar: null,\n        line: null,\n        s_single: null,\n        s_from: null,\n        s_to: null,\n        shad_single: null,\n        shad_from: null,\n        shad_to: null,\n        edge: null,\n        grid: null,\n        grid_labels: []\n      }; // storage for measure variables\n\n      this.coords = {\n        // left\n        x_gap: 0,\n        x_pointer: 0,\n        // width\n        w_rs: 0,\n        w_rs_old: 0,\n        w_handle: 0,\n        // percents\n        p_gap: 0,\n        p_gap_left: 0,\n        p_gap_right: 0,\n        p_step: 0,\n        p_pointer: 0,\n        p_handle: 0,\n        p_single_fake: 0,\n        p_single_real: 0,\n        p_from_fake: 0,\n        p_from_real: 0,\n        p_to_fake: 0,\n        p_to_real: 0,\n        p_bar_x: 0,\n        p_bar_w: 0,\n        // grid\n        grid_gap: 0,\n        big_num: 0,\n        big: [],\n        big_w: [],\n        big_p: [],\n        big_x: []\n      }; // storage for labels measure variables\n\n      this.labels = {\n        // width\n        w_min: 0,\n        w_max: 0,\n        w_from: 0,\n        w_to: 0,\n        w_single: 0,\n        // percents\n        p_min: 0,\n        p_max: 0,\n        p_from_fake: 0,\n        p_from_left: 0,\n        p_to_fake: 0,\n        p_to_left: 0,\n        p_single_fake: 0,\n        p_single_left: 0\n      };\n      /**\r\n       * get and validate config\r\n       */\n\n      var $inp = this.$cache.input,\n          val = $inp.prop(\"value\"),\n          config,\n          config_from_data,\n          prop; // default config\n\n      config = {\n        skin: \"flat\",\n        type: \"single\",\n        min: 10,\n        max: 100,\n        from: null,\n        to: null,\n        step: 1,\n        min_interval: 0,\n        max_interval: 0,\n        drag_interval: false,\n        values: [],\n        p_values: [],\n        from_fixed: false,\n        from_min: null,\n        from_max: null,\n        from_shadow: false,\n        to_fixed: false,\n        to_min: null,\n        to_max: null,\n        to_shadow: false,\n        prettify_enabled: true,\n        prettify_separator: \" \",\n        prettify: null,\n        force_edges: false,\n        keyboard: true,\n        grid: false,\n        grid_margin: true,\n        grid_num: 4,\n        grid_snap: false,\n        hide_min_max: false,\n        hide_from_to: false,\n        prefix: \"\",\n        postfix: \"\",\n        max_postfix: \"\",\n        decorate_both: true,\n        values_separator: \" — \",\n        input_values_separator: \";\",\n        disable: false,\n        block: false,\n        extra_classes: \"\",\n        scope: null,\n        onStart: null,\n        onChange: null,\n        onFinish: null,\n        onUpdate: null\n      }; // check if base element is input\n\n      if ($inp[0].nodeName !== \"INPUT\") {\n        console && console.warn && console.warn(\"Base element should be <input>!\", $inp[0]);\n      } // config from data-attributes extends js config\n\n\n      config_from_data = {\n        skin: $inp.data(\"skin\"),\n        type: $inp.data(\"type\"),\n        min: $inp.data(\"min\"),\n        max: $inp.data(\"max\"),\n        from: $inp.data(\"from\"),\n        to: $inp.data(\"to\"),\n        step: $inp.data(\"step\"),\n        min_interval: $inp.data(\"minInterval\"),\n        max_interval: $inp.data(\"maxInterval\"),\n        drag_interval: $inp.data(\"dragInterval\"),\n        values: $inp.data(\"values\"),\n        from_fixed: $inp.data(\"fromFixed\"),\n        from_min: $inp.data(\"fromMin\"),\n        from_max: $inp.data(\"fromMax\"),\n        from_shadow: $inp.data(\"fromShadow\"),\n        to_fixed: $inp.data(\"toFixed\"),\n        to_min: $inp.data(\"toMin\"),\n        to_max: $inp.data(\"toMax\"),\n        to_shadow: $inp.data(\"toShadow\"),\n        prettify_enabled: $inp.data(\"prettifyEnabled\"),\n        prettify_separator: $inp.data(\"prettifySeparator\"),\n        force_edges: $inp.data(\"forceEdges\"),\n        keyboard: $inp.data(\"keyboard\"),\n        grid: $inp.data(\"grid\"),\n        grid_margin: $inp.data(\"gridMargin\"),\n        grid_num: $inp.data(\"gridNum\"),\n        grid_snap: $inp.data(\"gridSnap\"),\n        hide_min_max: $inp.data(\"hideMinMax\"),\n        hide_from_to: $inp.data(\"hideFromTo\"),\n        prefix: $inp.data(\"prefix\"),\n        postfix: $inp.data(\"postfix\"),\n        max_postfix: $inp.data(\"maxPostfix\"),\n        decorate_both: $inp.data(\"decorateBoth\"),\n        values_separator: $inp.data(\"valuesSeparator\"),\n        input_values_separator: $inp.data(\"inputValuesSeparator\"),\n        disable: $inp.data(\"disable\"),\n        block: $inp.data(\"block\"),\n        extra_classes: $inp.data(\"extraClasses\")\n      };\n      config_from_data.values = config_from_data.values && config_from_data.values.split(\",\");\n\n      for (prop in config_from_data) {\n        if (config_from_data.hasOwnProperty(prop)) {\n          if (config_from_data[prop] === undefined || config_from_data[prop] === \"\") {\n            delete config_from_data[prop];\n          }\n        }\n      } // input value extends default config\n\n\n      if (val !== undefined && val !== \"\") {\n        val = val.split(config_from_data.input_values_separator || options.input_values_separator || \";\");\n\n        if (val[0] && val[0] == +val[0]) {\n          val[0] = +val[0];\n        }\n\n        if (val[1] && val[1] == +val[1]) {\n          val[1] = +val[1];\n        }\n\n        if (options && options.values && options.values.length) {\n          config.from = val[0] && options.values.indexOf(val[0]);\n          config.to = val[1] && options.values.indexOf(val[1]);\n        } else {\n          config.from = val[0] && +val[0];\n          config.to = val[1] && +val[1];\n        }\n      } // js config extends default config\n\n\n      $.extend(config, options); // data config extends config\n\n      $.extend(config, config_from_data);\n      this.options = config; // validate config, to be sure that all data types are correct\n\n      this.update_check = {};\n      this.validate(); // default result object, returned to callbacks\n\n      this.result = {\n        input: this.$cache.input,\n        slider: null,\n        min: this.options.min,\n        max: this.options.max,\n        from: this.options.from,\n        from_percent: 0,\n        from_value: null,\n        to: this.options.to,\n        to_percent: 0,\n        to_value: null\n      };\n      this.init();\n    };\n\n    IonRangeSlider.prototype = {\n      /**\r\n       * Starts or updates the plugin instance\r\n       *\r\n       * @param [is_update] {boolean}\r\n       */\n      init: function (is_update) {\n        this.no_diapason = false;\n        this.coords.p_step = this.convertToPercent(this.options.step, true);\n        this.target = \"base\";\n        this.toggleInput();\n        this.append();\n        this.setMinMax();\n\n        if (is_update) {\n          this.force_redraw = true;\n          this.calc(true); // callbacks called\n\n          this.callOnUpdate();\n        } else {\n          this.force_redraw = true;\n          this.calc(true); // callbacks called\n\n          this.callOnStart();\n        }\n\n        this.updateScene();\n      },\n\n      /**\r\n       * Appends slider template to a DOM\r\n       */\n      append: function () {\n        var container_html = '<span class=\"irs irs--' + this.options.skin + ' js-irs-' + this.plugin_count + ' ' + this.options.extra_classes + '\"></span>';\n        this.$cache.input.before(container_html);\n        this.$cache.input.prop(\"readonly\", true);\n        this.$cache.cont = this.$cache.input.prev();\n        this.result.slider = this.$cache.cont;\n        this.$cache.cont.html(base_html);\n        this.$cache.rs = this.$cache.cont.find(\".irs\");\n        this.$cache.min = this.$cache.cont.find(\".irs-min\");\n        this.$cache.max = this.$cache.cont.find(\".irs-max\");\n        this.$cache.from = this.$cache.cont.find(\".irs-from\");\n        this.$cache.to = this.$cache.cont.find(\".irs-to\");\n        this.$cache.single = this.$cache.cont.find(\".irs-single\");\n        this.$cache.line = this.$cache.cont.find(\".irs-line\");\n        this.$cache.grid = this.$cache.cont.find(\".irs-grid\");\n\n        if (this.options.type === \"single\") {\n          this.$cache.cont.append(single_html);\n          this.$cache.bar = this.$cache.cont.find(\".irs-bar\");\n          this.$cache.edge = this.$cache.cont.find(\".irs-bar-edge\");\n          this.$cache.s_single = this.$cache.cont.find(\".single\");\n          this.$cache.from[0].style.visibility = \"hidden\";\n          this.$cache.to[0].style.visibility = \"hidden\";\n          this.$cache.shad_single = this.$cache.cont.find(\".shadow-single\");\n        } else {\n          this.$cache.cont.append(double_html);\n          this.$cache.bar = this.$cache.cont.find(\".irs-bar\");\n          this.$cache.s_from = this.$cache.cont.find(\".from\");\n          this.$cache.s_to = this.$cache.cont.find(\".to\");\n          this.$cache.shad_from = this.$cache.cont.find(\".shadow-from\");\n          this.$cache.shad_to = this.$cache.cont.find(\".shadow-to\");\n          this.setTopHandler();\n        }\n\n        if (this.options.hide_from_to) {\n          this.$cache.from[0].style.display = \"none\";\n          this.$cache.to[0].style.display = \"none\";\n          this.$cache.single[0].style.display = \"none\";\n        }\n\n        this.appendGrid();\n\n        if (this.options.disable) {\n          this.appendDisableMask();\n          this.$cache.input[0].disabled = true;\n        } else {\n          this.$cache.input[0].disabled = false;\n          this.removeDisableMask();\n          this.bindEvents();\n        } // block only if not disabled\n\n\n        if (!this.options.disable) {\n          if (this.options.block) {\n            this.appendDisableMask();\n          } else {\n            this.removeDisableMask();\n          }\n        }\n\n        if (this.options.drag_interval) {\n          this.$cache.bar[0].style.cursor = \"ew-resize\";\n        }\n      },\n\n      /**\r\n       * Determine which handler has a priority\r\n       * works only for double slider type\r\n       */\n      setTopHandler: function () {\n        var min = this.options.min,\n            max = this.options.max,\n            from = this.options.from,\n            to = this.options.to;\n\n        if (from > min && to === max) {\n          this.$cache.s_from.addClass(\"type_last\");\n        } else if (to < max) {\n          this.$cache.s_to.addClass(\"type_last\");\n        }\n      },\n\n      /**\r\n       * Determine which handles was clicked last\r\n       * and which handler should have hover effect\r\n       *\r\n       * @param target {String}\r\n       */\n      changeLevel: function (target) {\n        switch (target) {\n          case \"single\":\n            this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_single_fake);\n            this.$cache.s_single.addClass(\"state_hover\");\n            break;\n\n          case \"from\":\n            this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_from_fake);\n            this.$cache.s_from.addClass(\"state_hover\");\n            this.$cache.s_from.addClass(\"type_last\");\n            this.$cache.s_to.removeClass(\"type_last\");\n            break;\n\n          case \"to\":\n            this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_to_fake);\n            this.$cache.s_to.addClass(\"state_hover\");\n            this.$cache.s_to.addClass(\"type_last\");\n            this.$cache.s_from.removeClass(\"type_last\");\n            break;\n\n          case \"both\":\n            this.coords.p_gap_left = this.toFixed(this.coords.p_pointer - this.coords.p_from_fake);\n            this.coords.p_gap_right = this.toFixed(this.coords.p_to_fake - this.coords.p_pointer);\n            this.$cache.s_to.removeClass(\"type_last\");\n            this.$cache.s_from.removeClass(\"type_last\");\n            break;\n        }\n      },\n\n      /**\r\n       * Then slider is disabled\r\n       * appends extra layer with opacity\r\n       */\n      appendDisableMask: function () {\n        this.$cache.cont.append(disable_html);\n        this.$cache.cont.addClass(\"irs-disabled\");\n      },\n\n      /**\r\n       * Then slider is not disabled\r\n       * remove disable mask\r\n       */\n      removeDisableMask: function () {\n        this.$cache.cont.remove(\".irs-disable-mask\");\n        this.$cache.cont.removeClass(\"irs-disabled\");\n      },\n\n      /**\r\n       * Remove slider instance\r\n       * and unbind all events\r\n       */\n      remove: function () {\n        this.$cache.cont.remove();\n        this.$cache.cont = null;\n        this.$cache.line.off(\"keydown.irs_\" + this.plugin_count);\n        this.$cache.body.off(\"touchmove.irs_\" + this.plugin_count);\n        this.$cache.body.off(\"mousemove.irs_\" + this.plugin_count);\n        this.$cache.win.off(\"touchend.irs_\" + this.plugin_count);\n        this.$cache.win.off(\"mouseup.irs_\" + this.plugin_count);\n\n        if (is_old_ie) {\n          this.$cache.body.off(\"mouseup.irs_\" + this.plugin_count);\n          this.$cache.body.off(\"mouseleave.irs_\" + this.plugin_count);\n        }\n\n        this.$cache.grid_labels = [];\n        this.coords.big = [];\n        this.coords.big_w = [];\n        this.coords.big_p = [];\n        this.coords.big_x = [];\n        cancelAnimationFrame(this.raf_id);\n      },\n\n      /**\r\n       * bind all slider events\r\n       */\n      bindEvents: function () {\n        if (this.no_diapason) {\n          return;\n        }\n\n        this.$cache.body.on(\"touchmove.irs_\" + this.plugin_count, this.pointerMove.bind(this));\n        this.$cache.body.on(\"mousemove.irs_\" + this.plugin_count, this.pointerMove.bind(this));\n        this.$cache.win.on(\"touchend.irs_\" + this.plugin_count, this.pointerUp.bind(this));\n        this.$cache.win.on(\"mouseup.irs_\" + this.plugin_count, this.pointerUp.bind(this));\n        this.$cache.line.on(\"touchstart.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n        this.$cache.line.on(\"mousedown.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n        this.$cache.line.on(\"focus.irs_\" + this.plugin_count, this.pointerFocus.bind(this));\n\n        if (this.options.drag_interval && this.options.type === \"double\") {\n          this.$cache.bar.on(\"touchstart.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"both\"));\n          this.$cache.bar.on(\"mousedown.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"both\"));\n        } else {\n          this.$cache.bar.on(\"touchstart.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n          this.$cache.bar.on(\"mousedown.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n        }\n\n        if (this.options.type === \"single\") {\n          this.$cache.single.on(\"touchstart.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"single\"));\n          this.$cache.s_single.on(\"touchstart.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"single\"));\n          this.$cache.shad_single.on(\"touchstart.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n          this.$cache.single.on(\"mousedown.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"single\"));\n          this.$cache.s_single.on(\"mousedown.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"single\"));\n          this.$cache.edge.on(\"mousedown.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n          this.$cache.shad_single.on(\"mousedown.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n        } else {\n          this.$cache.single.on(\"touchstart.irs_\" + this.plugin_count, this.pointerDown.bind(this, null));\n          this.$cache.single.on(\"mousedown.irs_\" + this.plugin_count, this.pointerDown.bind(this, null));\n          this.$cache.from.on(\"touchstart.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"from\"));\n          this.$cache.s_from.on(\"touchstart.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"from\"));\n          this.$cache.to.on(\"touchstart.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"to\"));\n          this.$cache.s_to.on(\"touchstart.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"to\"));\n          this.$cache.shad_from.on(\"touchstart.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n          this.$cache.shad_to.on(\"touchstart.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n          this.$cache.from.on(\"mousedown.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"from\"));\n          this.$cache.s_from.on(\"mousedown.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"from\"));\n          this.$cache.to.on(\"mousedown.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"to\"));\n          this.$cache.s_to.on(\"mousedown.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"to\"));\n          this.$cache.shad_from.on(\"mousedown.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n          this.$cache.shad_to.on(\"mousedown.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n        }\n\n        if (this.options.keyboard) {\n          this.$cache.line.on(\"keydown.irs_\" + this.plugin_count, this.key.bind(this, \"keyboard\"));\n        }\n\n        if (is_old_ie) {\n          this.$cache.body.on(\"mouseup.irs_\" + this.plugin_count, this.pointerUp.bind(this));\n          this.$cache.body.on(\"mouseleave.irs_\" + this.plugin_count, this.pointerUp.bind(this));\n        }\n      },\n\n      /**\r\n       * Focus with tabIndex\r\n       *\r\n       * @param e {Object} event object\r\n       */\n      pointerFocus: function (e) {\n        if (!this.target) {\n          var x;\n          var $handle;\n\n          if (this.options.type === \"single\") {\n            $handle = this.$cache.single;\n          } else {\n            $handle = this.$cache.from;\n          }\n\n          x = $handle.offset().left;\n          x += $handle.width() / 2 - 1;\n          this.pointerClick(\"single\", {\n            preventDefault: function () {},\n            pageX: x\n          });\n        }\n      },\n\n      /**\r\n       * Mousemove or touchmove\r\n       * only for handlers\r\n       *\r\n       * @param e {Object} event object\r\n       */\n      pointerMove: function (e) {\n        if (!this.dragging) {\n          return;\n        }\n\n        var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;\n        this.coords.x_pointer = x - this.coords.x_gap;\n        this.calc();\n      },\n\n      /**\r\n       * Mouseup or touchend\r\n       * only for handlers\r\n       *\r\n       * @param e {Object} event object\r\n       */\n      pointerUp: function (e) {\n        if (this.current_plugin !== this.plugin_count) {\n          return;\n        }\n\n        if (this.is_active) {\n          this.is_active = false;\n        } else {\n          return;\n        }\n\n        this.$cache.cont.find(\".state_hover\").removeClass(\"state_hover\");\n        this.force_redraw = true;\n\n        if (is_old_ie) {\n          $(\"*\").prop(\"unselectable\", false);\n        }\n\n        this.updateScene();\n        this.restoreOriginalMinInterval(); // callbacks call\n\n        if ($.contains(this.$cache.cont[0], e.target) || this.dragging) {\n          this.callOnFinish();\n        }\n\n        this.dragging = false;\n      },\n\n      /**\r\n       * Mousedown or touchstart\r\n       * only for handlers\r\n       *\r\n       * @param target {String|null}\r\n       * @param e {Object} event object\r\n       */\n      pointerDown: function (target, e) {\n        e.preventDefault();\n        var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;\n\n        if (e.button === 2) {\n          return;\n        }\n\n        if (target === \"both\") {\n          this.setTempMinInterval();\n        }\n\n        if (!target) {\n          target = this.target || \"from\";\n        }\n\n        this.current_plugin = this.plugin_count;\n        this.target = target;\n        this.is_active = true;\n        this.dragging = true;\n        this.coords.x_gap = this.$cache.rs.offset().left;\n        this.coords.x_pointer = x - this.coords.x_gap;\n        this.calcPointerPercent();\n        this.changeLevel(target);\n\n        if (is_old_ie) {\n          $(\"*\").prop(\"unselectable\", true);\n        }\n\n        this.$cache.line.trigger(\"focus\");\n        this.updateScene();\n      },\n\n      /**\r\n       * Mousedown or touchstart\r\n       * for other slider elements, like diapason line\r\n       *\r\n       * @param target {String}\r\n       * @param e {Object} event object\r\n       */\n      pointerClick: function (target, e) {\n        e.preventDefault();\n        var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;\n\n        if (e.button === 2) {\n          return;\n        }\n\n        this.current_plugin = this.plugin_count;\n        this.target = target;\n        this.is_click = true;\n        this.coords.x_gap = this.$cache.rs.offset().left;\n        this.coords.x_pointer = +(x - this.coords.x_gap).toFixed();\n        this.force_redraw = true;\n        this.calc();\n        this.$cache.line.trigger(\"focus\");\n      },\n\n      /**\r\n       * Keyborard controls for focused slider\r\n       *\r\n       * @param target {String}\r\n       * @param e {Object} event object\r\n       * @returns {boolean|undefined}\r\n       */\n      key: function (target, e) {\n        if (this.current_plugin !== this.plugin_count || e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {\n          return;\n        }\n\n        switch (e.which) {\n          case 83: // W\n\n          case 65: // A\n\n          case 40: // DOWN\n\n          case 37:\n            // LEFT\n            e.preventDefault();\n            this.moveByKey(false);\n            break;\n\n          case 87: // S\n\n          case 68: // D\n\n          case 38: // UP\n\n          case 39:\n            // RIGHT\n            e.preventDefault();\n            this.moveByKey(true);\n            break;\n        }\n\n        return true;\n      },\n\n      /**\r\n       * Move by key\r\n       *\r\n       * @param right {boolean} direction to move\r\n       */\n      moveByKey: function (right) {\n        var p = this.coords.p_pointer;\n        var p_step = (this.options.max - this.options.min) / 100;\n        p_step = this.options.step / p_step;\n\n        if (right) {\n          p += p_step;\n        } else {\n          p -= p_step;\n        }\n\n        this.coords.x_pointer = this.toFixed(this.coords.w_rs / 100 * p);\n        this.is_key = true;\n        this.calc();\n      },\n\n      /**\r\n       * Set visibility and content\r\n       * of Min and Max labels\r\n       */\n      setMinMax: function () {\n        if (!this.options) {\n          return;\n        }\n\n        if (this.options.hide_min_max) {\n          this.$cache.min[0].style.display = \"none\";\n          this.$cache.max[0].style.display = \"none\";\n          return;\n        }\n\n        if (this.options.values.length) {\n          this.$cache.min.html(this.decorate(this.options.p_values[this.options.min]));\n          this.$cache.max.html(this.decorate(this.options.p_values[this.options.max]));\n        } else {\n          var min_pretty = this._prettify(this.options.min);\n\n          var max_pretty = this._prettify(this.options.max);\n\n          this.result.min_pretty = min_pretty;\n          this.result.max_pretty = max_pretty;\n          this.$cache.min.html(this.decorate(min_pretty, this.options.min));\n          this.$cache.max.html(this.decorate(max_pretty, this.options.max));\n        }\n\n        this.labels.w_min = this.$cache.min.outerWidth(false);\n        this.labels.w_max = this.$cache.max.outerWidth(false);\n      },\n\n      /**\r\n       * Then dragging interval, prevent interval collapsing\r\n       * using min_interval option\r\n       */\n      setTempMinInterval: function () {\n        var interval = this.result.to - this.result.from;\n\n        if (this.old_min_interval === null) {\n          this.old_min_interval = this.options.min_interval;\n        }\n\n        this.options.min_interval = interval;\n      },\n\n      /**\r\n       * Restore min_interval option to original\r\n       */\n      restoreOriginalMinInterval: function () {\n        if (this.old_min_interval !== null) {\n          this.options.min_interval = this.old_min_interval;\n          this.old_min_interval = null;\n        }\n      },\n      // =============================================================================================================\n      // Calculations\n\n      /**\r\n       * All calculations and measures start here\r\n       *\r\n       * @param update {boolean=}\r\n       */\n      calc: function (update) {\n        if (!this.options) {\n          return;\n        }\n\n        this.calc_count++;\n\n        if (this.calc_count === 10 || update) {\n          this.calc_count = 0;\n          this.coords.w_rs = this.$cache.rs.outerWidth(false);\n          this.calcHandlePercent();\n        }\n\n        if (!this.coords.w_rs) {\n          return;\n        }\n\n        this.calcPointerPercent();\n        var handle_x = this.getHandleX();\n\n        if (this.target === \"both\") {\n          this.coords.p_gap = 0;\n          handle_x = this.getHandleX();\n        }\n\n        if (this.target === \"click\") {\n          this.coords.p_gap = this.coords.p_handle / 2;\n          handle_x = this.getHandleX();\n\n          if (this.options.drag_interval) {\n            this.target = \"both_one\";\n          } else {\n            this.target = this.chooseHandle(handle_x);\n          }\n        }\n\n        switch (this.target) {\n          case \"base\":\n            var w = (this.options.max - this.options.min) / 100,\n                f = (this.result.from - this.options.min) / w,\n                t = (this.result.to - this.options.min) / w;\n            this.coords.p_single_real = this.toFixed(f);\n            this.coords.p_from_real = this.toFixed(f);\n            this.coords.p_to_real = this.toFixed(t);\n            this.coords.p_single_real = this.checkDiapason(this.coords.p_single_real, this.options.from_min, this.options.from_max);\n            this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);\n            this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);\n            this.coords.p_single_fake = this.convertToFakePercent(this.coords.p_single_real);\n            this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);\n            this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);\n            this.target = null;\n            break;\n\n          case \"single\":\n            if (this.options.from_fixed) {\n              break;\n            }\n\n            this.coords.p_single_real = this.convertToRealPercent(handle_x);\n            this.coords.p_single_real = this.calcWithStep(this.coords.p_single_real);\n            this.coords.p_single_real = this.checkDiapason(this.coords.p_single_real, this.options.from_min, this.options.from_max);\n            this.coords.p_single_fake = this.convertToFakePercent(this.coords.p_single_real);\n            break;\n\n          case \"from\":\n            if (this.options.from_fixed) {\n              break;\n            }\n\n            this.coords.p_from_real = this.convertToRealPercent(handle_x);\n            this.coords.p_from_real = this.calcWithStep(this.coords.p_from_real);\n\n            if (this.coords.p_from_real > this.coords.p_to_real) {\n              this.coords.p_from_real = this.coords.p_to_real;\n            }\n\n            this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);\n            this.coords.p_from_real = this.checkMinInterval(this.coords.p_from_real, this.coords.p_to_real, \"from\");\n            this.coords.p_from_real = this.checkMaxInterval(this.coords.p_from_real, this.coords.p_to_real, \"from\");\n            this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);\n            break;\n\n          case \"to\":\n            if (this.options.to_fixed) {\n              break;\n            }\n\n            this.coords.p_to_real = this.convertToRealPercent(handle_x);\n            this.coords.p_to_real = this.calcWithStep(this.coords.p_to_real);\n\n            if (this.coords.p_to_real < this.coords.p_from_real) {\n              this.coords.p_to_real = this.coords.p_from_real;\n            }\n\n            this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);\n            this.coords.p_to_real = this.checkMinInterval(this.coords.p_to_real, this.coords.p_from_real, \"to\");\n            this.coords.p_to_real = this.checkMaxInterval(this.coords.p_to_real, this.coords.p_from_real, \"to\");\n            this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);\n            break;\n\n          case \"both\":\n            if (this.options.from_fixed || this.options.to_fixed) {\n              break;\n            }\n\n            handle_x = this.toFixed(handle_x + this.coords.p_handle * 0.001);\n            this.coords.p_from_real = this.convertToRealPercent(handle_x) - this.coords.p_gap_left;\n            this.coords.p_from_real = this.calcWithStep(this.coords.p_from_real);\n            this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);\n            this.coords.p_from_real = this.checkMinInterval(this.coords.p_from_real, this.coords.p_to_real, \"from\");\n            this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);\n            this.coords.p_to_real = this.convertToRealPercent(handle_x) + this.coords.p_gap_right;\n            this.coords.p_to_real = this.calcWithStep(this.coords.p_to_real);\n            this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);\n            this.coords.p_to_real = this.checkMinInterval(this.coords.p_to_real, this.coords.p_from_real, \"to\");\n            this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);\n            break;\n\n          case \"both_one\":\n            if (this.options.from_fixed || this.options.to_fixed) {\n              break;\n            }\n\n            var real_x = this.convertToRealPercent(handle_x),\n                from = this.result.from_percent,\n                to = this.result.to_percent,\n                full = to - from,\n                half = full / 2,\n                new_from = real_x - half,\n                new_to = real_x + half;\n\n            if (new_from < 0) {\n              new_from = 0;\n              new_to = new_from + full;\n            }\n\n            if (new_to > 100) {\n              new_to = 100;\n              new_from = new_to - full;\n            }\n\n            this.coords.p_from_real = this.calcWithStep(new_from);\n            this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);\n            this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);\n            this.coords.p_to_real = this.calcWithStep(new_to);\n            this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);\n            this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);\n            break;\n        }\n\n        if (this.options.type === \"single\") {\n          this.coords.p_bar_x = this.coords.p_handle / 2;\n          this.coords.p_bar_w = this.coords.p_single_fake;\n          this.result.from_percent = this.coords.p_single_real;\n          this.result.from = this.convertToValue(this.coords.p_single_real);\n          this.result.from_pretty = this._prettify(this.result.from);\n\n          if (this.options.values.length) {\n            this.result.from_value = this.options.values[this.result.from];\n          }\n        } else {\n          this.coords.p_bar_x = this.toFixed(this.coords.p_from_fake + this.coords.p_handle / 2);\n          this.coords.p_bar_w = this.toFixed(this.coords.p_to_fake - this.coords.p_from_fake);\n          this.result.from_percent = this.coords.p_from_real;\n          this.result.from = this.convertToValue(this.coords.p_from_real);\n          this.result.from_pretty = this._prettify(this.result.from);\n          this.result.to_percent = this.coords.p_to_real;\n          this.result.to = this.convertToValue(this.coords.p_to_real);\n          this.result.to_pretty = this._prettify(this.result.to);\n\n          if (this.options.values.length) {\n            this.result.from_value = this.options.values[this.result.from];\n            this.result.to_value = this.options.values[this.result.to];\n          }\n        }\n\n        this.calcMinMax();\n        this.calcLabels();\n      },\n\n      /**\r\n       * calculates pointer X in percent\r\n       */\n      calcPointerPercent: function () {\n        if (!this.coords.w_rs) {\n          this.coords.p_pointer = 0;\n          return;\n        }\n\n        if (this.coords.x_pointer < 0 || isNaN(this.coords.x_pointer)) {\n          this.coords.x_pointer = 0;\n        } else if (this.coords.x_pointer > this.coords.w_rs) {\n          this.coords.x_pointer = this.coords.w_rs;\n        }\n\n        this.coords.p_pointer = this.toFixed(this.coords.x_pointer / this.coords.w_rs * 100);\n      },\n      convertToRealPercent: function (fake) {\n        var full = 100 - this.coords.p_handle;\n        return fake / full * 100;\n      },\n      convertToFakePercent: function (real) {\n        var full = 100 - this.coords.p_handle;\n        return real / 100 * full;\n      },\n      getHandleX: function () {\n        var max = 100 - this.coords.p_handle,\n            x = this.toFixed(this.coords.p_pointer - this.coords.p_gap);\n\n        if (x < 0) {\n          x = 0;\n        } else if (x > max) {\n          x = max;\n        }\n\n        return x;\n      },\n      calcHandlePercent: function () {\n        if (this.options.type === \"single\") {\n          this.coords.w_handle = this.$cache.s_single.outerWidth(false);\n        } else {\n          this.coords.w_handle = this.$cache.s_from.outerWidth(false);\n        }\n\n        this.coords.p_handle = this.toFixed(this.coords.w_handle / this.coords.w_rs * 100);\n      },\n\n      /**\r\n       * Find closest handle to pointer click\r\n       *\r\n       * @param real_x {Number}\r\n       * @returns {String}\r\n       */\n      chooseHandle: function (real_x) {\n        if (this.options.type === \"single\") {\n          return \"single\";\n        } else {\n          var m_point = this.coords.p_from_real + (this.coords.p_to_real - this.coords.p_from_real) / 2;\n\n          if (real_x >= m_point) {\n            return this.options.to_fixed ? \"from\" : \"to\";\n          } else {\n            return this.options.from_fixed ? \"to\" : \"from\";\n          }\n        }\n      },\n\n      /**\r\n       * Measure Min and Max labels width in percent\r\n       */\n      calcMinMax: function () {\n        if (!this.coords.w_rs) {\n          return;\n        }\n\n        this.labels.p_min = this.labels.w_min / this.coords.w_rs * 100;\n        this.labels.p_max = this.labels.w_max / this.coords.w_rs * 100;\n      },\n\n      /**\r\n       * Measure labels width and X in percent\r\n       */\n      calcLabels: function () {\n        if (!this.coords.w_rs || this.options.hide_from_to) {\n          return;\n        }\n\n        if (this.options.type === \"single\") {\n          this.labels.w_single = this.$cache.single.outerWidth(false);\n          this.labels.p_single_fake = this.labels.w_single / this.coords.w_rs * 100;\n          this.labels.p_single_left = this.coords.p_single_fake + this.coords.p_handle / 2 - this.labels.p_single_fake / 2;\n          this.labels.p_single_left = this.checkEdges(this.labels.p_single_left, this.labels.p_single_fake);\n        } else {\n          this.labels.w_from = this.$cache.from.outerWidth(false);\n          this.labels.p_from_fake = this.labels.w_from / this.coords.w_rs * 100;\n          this.labels.p_from_left = this.coords.p_from_fake + this.coords.p_handle / 2 - this.labels.p_from_fake / 2;\n          this.labels.p_from_left = this.toFixed(this.labels.p_from_left);\n          this.labels.p_from_left = this.checkEdges(this.labels.p_from_left, this.labels.p_from_fake);\n          this.labels.w_to = this.$cache.to.outerWidth(false);\n          this.labels.p_to_fake = this.labels.w_to / this.coords.w_rs * 100;\n          this.labels.p_to_left = this.coords.p_to_fake + this.coords.p_handle / 2 - this.labels.p_to_fake / 2;\n          this.labels.p_to_left = this.toFixed(this.labels.p_to_left);\n          this.labels.p_to_left = this.checkEdges(this.labels.p_to_left, this.labels.p_to_fake);\n          this.labels.w_single = this.$cache.single.outerWidth(false);\n          this.labels.p_single_fake = this.labels.w_single / this.coords.w_rs * 100;\n          this.labels.p_single_left = (this.labels.p_from_left + this.labels.p_to_left + this.labels.p_to_fake) / 2 - this.labels.p_single_fake / 2;\n          this.labels.p_single_left = this.toFixed(this.labels.p_single_left);\n          this.labels.p_single_left = this.checkEdges(this.labels.p_single_left, this.labels.p_single_fake);\n        }\n      },\n      // =============================================================================================================\n      // Drawings\n\n      /**\r\n       * Main function called in request animation frame\r\n       * to update everything\r\n       */\n      updateScene: function () {\n        if (this.raf_id) {\n          cancelAnimationFrame(this.raf_id);\n          this.raf_id = null;\n        }\n\n        clearTimeout(this.update_tm);\n        this.update_tm = null;\n\n        if (!this.options) {\n          return;\n        }\n\n        this.drawHandles();\n\n        if (this.is_active) {\n          this.raf_id = requestAnimationFrame(this.updateScene.bind(this));\n        } else {\n          this.update_tm = setTimeout(this.updateScene.bind(this), 300);\n        }\n      },\n\n      /**\r\n       * Draw handles\r\n       */\n      drawHandles: function () {\n        this.coords.w_rs = this.$cache.rs.outerWidth(false);\n\n        if (!this.coords.w_rs) {\n          return;\n        }\n\n        if (this.coords.w_rs !== this.coords.w_rs_old) {\n          this.target = \"base\";\n          this.is_resize = true;\n        }\n\n        if (this.coords.w_rs !== this.coords.w_rs_old || this.force_redraw) {\n          this.setMinMax();\n          this.calc(true);\n          this.drawLabels();\n\n          if (this.options.grid) {\n            this.calcGridMargin();\n            this.calcGridLabels();\n          }\n\n          this.force_redraw = true;\n          this.coords.w_rs_old = this.coords.w_rs;\n          this.drawShadow();\n        }\n\n        if (!this.coords.w_rs) {\n          return;\n        }\n\n        if (!this.dragging && !this.force_redraw && !this.is_key) {\n          return;\n        }\n\n        if (this.old_from !== this.result.from || this.old_to !== this.result.to || this.force_redraw || this.is_key) {\n          this.drawLabels();\n          this.$cache.bar[0].style.left = this.coords.p_bar_x + \"%\";\n          this.$cache.bar[0].style.width = this.coords.p_bar_w + \"%\";\n\n          if (this.options.type === \"single\") {\n            this.$cache.bar[0].style.left = 0;\n            this.$cache.bar[0].style.width = this.coords.p_bar_w + this.coords.p_bar_x + \"%\";\n            this.$cache.s_single[0].style.left = this.coords.p_single_fake + \"%\";\n            this.$cache.single[0].style.left = this.labels.p_single_left + \"%\";\n          } else {\n            this.$cache.s_from[0].style.left = this.coords.p_from_fake + \"%\";\n            this.$cache.s_to[0].style.left = this.coords.p_to_fake + \"%\";\n\n            if (this.old_from !== this.result.from || this.force_redraw) {\n              this.$cache.from[0].style.left = this.labels.p_from_left + \"%\";\n            }\n\n            if (this.old_to !== this.result.to || this.force_redraw) {\n              this.$cache.to[0].style.left = this.labels.p_to_left + \"%\";\n            }\n\n            this.$cache.single[0].style.left = this.labels.p_single_left + \"%\";\n          }\n\n          this.writeToInput();\n\n          if ((this.old_from !== this.result.from || this.old_to !== this.result.to) && !this.is_start) {\n            this.$cache.input.trigger(\"change\");\n            this.$cache.input.trigger(\"input\");\n          }\n\n          this.old_from = this.result.from;\n          this.old_to = this.result.to; // callbacks call\n\n          if (!this.is_resize && !this.is_update && !this.is_start && !this.is_finish) {\n            this.callOnChange();\n          }\n\n          if (this.is_key || this.is_click) {\n            this.is_key = false;\n            this.is_click = false;\n            this.callOnFinish();\n          }\n\n          this.is_update = false;\n          this.is_resize = false;\n          this.is_finish = false;\n        }\n\n        this.is_start = false;\n        this.is_key = false;\n        this.is_click = false;\n        this.force_redraw = false;\n      },\n\n      /**\r\n       * Draw labels\r\n       * measure labels collisions\r\n       * collapse close labels\r\n       */\n      drawLabels: function () {\n        if (!this.options) {\n          return;\n        }\n\n        var values_num = this.options.values.length;\n        var p_values = this.options.p_values;\n        var text_single;\n        var text_from;\n        var text_to;\n        var from_pretty;\n        var to_pretty;\n\n        if (this.options.hide_from_to) {\n          return;\n        }\n\n        if (this.options.type === \"single\") {\n          if (values_num) {\n            text_single = this.decorate(p_values[this.result.from]);\n            this.$cache.single.html(text_single);\n          } else {\n            from_pretty = this._prettify(this.result.from);\n            text_single = this.decorate(from_pretty, this.result.from);\n            this.$cache.single.html(text_single);\n          }\n\n          this.calcLabels();\n\n          if (this.labels.p_single_left < this.labels.p_min + 1) {\n            this.$cache.min[0].style.visibility = \"hidden\";\n          } else {\n            this.$cache.min[0].style.visibility = \"visible\";\n          }\n\n          if (this.labels.p_single_left + this.labels.p_single_fake > 100 - this.labels.p_max - 1) {\n            this.$cache.max[0].style.visibility = \"hidden\";\n          } else {\n            this.$cache.max[0].style.visibility = \"visible\";\n          }\n        } else {\n          if (values_num) {\n            if (this.options.decorate_both) {\n              text_single = this.decorate(p_values[this.result.from]);\n              text_single += this.options.values_separator;\n              text_single += this.decorate(p_values[this.result.to]);\n            } else {\n              text_single = this.decorate(p_values[this.result.from] + this.options.values_separator + p_values[this.result.to]);\n            }\n\n            text_from = this.decorate(p_values[this.result.from]);\n            text_to = this.decorate(p_values[this.result.to]);\n            this.$cache.single.html(text_single);\n            this.$cache.from.html(text_from);\n            this.$cache.to.html(text_to);\n          } else {\n            from_pretty = this._prettify(this.result.from);\n            to_pretty = this._prettify(this.result.to);\n\n            if (this.options.decorate_both) {\n              text_single = this.decorate(from_pretty, this.result.from);\n              text_single += this.options.values_separator;\n              text_single += this.decorate(to_pretty, this.result.to);\n            } else {\n              text_single = this.decorate(from_pretty + this.options.values_separator + to_pretty, this.result.to);\n            }\n\n            text_from = this.decorate(from_pretty, this.result.from);\n            text_to = this.decorate(to_pretty, this.result.to);\n            this.$cache.single.html(text_single);\n            this.$cache.from.html(text_from);\n            this.$cache.to.html(text_to);\n          }\n\n          this.calcLabels();\n          var min = Math.min(this.labels.p_single_left, this.labels.p_from_left),\n              single_left = this.labels.p_single_left + this.labels.p_single_fake,\n              to_left = this.labels.p_to_left + this.labels.p_to_fake,\n              max = Math.max(single_left, to_left);\n\n          if (this.labels.p_from_left + this.labels.p_from_fake >= this.labels.p_to_left) {\n            this.$cache.from[0].style.visibility = \"hidden\";\n            this.$cache.to[0].style.visibility = \"hidden\";\n            this.$cache.single[0].style.visibility = \"visible\";\n\n            if (this.result.from === this.result.to) {\n              if (this.target === \"from\") {\n                this.$cache.from[0].style.visibility = \"visible\";\n              } else if (this.target === \"to\") {\n                this.$cache.to[0].style.visibility = \"visible\";\n              } else if (!this.target) {\n                this.$cache.from[0].style.visibility = \"visible\";\n              }\n\n              this.$cache.single[0].style.visibility = \"hidden\";\n              max = to_left;\n            } else {\n              this.$cache.from[0].style.visibility = \"hidden\";\n              this.$cache.to[0].style.visibility = \"hidden\";\n              this.$cache.single[0].style.visibility = \"visible\";\n              max = Math.max(single_left, to_left);\n            }\n          } else {\n            this.$cache.from[0].style.visibility = \"visible\";\n            this.$cache.to[0].style.visibility = \"visible\";\n            this.$cache.single[0].style.visibility = \"hidden\";\n          }\n\n          if (min < this.labels.p_min + 1) {\n            this.$cache.min[0].style.visibility = \"hidden\";\n          } else {\n            this.$cache.min[0].style.visibility = \"visible\";\n          }\n\n          if (max > 100 - this.labels.p_max - 1) {\n            this.$cache.max[0].style.visibility = \"hidden\";\n          } else {\n            this.$cache.max[0].style.visibility = \"visible\";\n          }\n        }\n      },\n\n      /**\r\n       * Draw shadow intervals\r\n       */\n      drawShadow: function () {\n        var o = this.options,\n            c = this.$cache,\n            is_from_min = typeof o.from_min === \"number\" && !isNaN(o.from_min),\n            is_from_max = typeof o.from_max === \"number\" && !isNaN(o.from_max),\n            is_to_min = typeof o.to_min === \"number\" && !isNaN(o.to_min),\n            is_to_max = typeof o.to_max === \"number\" && !isNaN(o.to_max),\n            from_min,\n            from_max,\n            to_min,\n            to_max;\n\n        if (o.type === \"single\") {\n          if (o.from_shadow && (is_from_min || is_from_max)) {\n            from_min = this.convertToPercent(is_from_min ? o.from_min : o.min);\n            from_max = this.convertToPercent(is_from_max ? o.from_max : o.max) - from_min;\n            from_min = this.toFixed(from_min - this.coords.p_handle / 100 * from_min);\n            from_max = this.toFixed(from_max - this.coords.p_handle / 100 * from_max);\n            from_min = from_min + this.coords.p_handle / 2;\n            c.shad_single[0].style.display = \"block\";\n            c.shad_single[0].style.left = from_min + \"%\";\n            c.shad_single[0].style.width = from_max + \"%\";\n          } else {\n            c.shad_single[0].style.display = \"none\";\n          }\n        } else {\n          if (o.from_shadow && (is_from_min || is_from_max)) {\n            from_min = this.convertToPercent(is_from_min ? o.from_min : o.min);\n            from_max = this.convertToPercent(is_from_max ? o.from_max : o.max) - from_min;\n            from_min = this.toFixed(from_min - this.coords.p_handle / 100 * from_min);\n            from_max = this.toFixed(from_max - this.coords.p_handle / 100 * from_max);\n            from_min = from_min + this.coords.p_handle / 2;\n            c.shad_from[0].style.display = \"block\";\n            c.shad_from[0].style.left = from_min + \"%\";\n            c.shad_from[0].style.width = from_max + \"%\";\n          } else {\n            c.shad_from[0].style.display = \"none\";\n          }\n\n          if (o.to_shadow && (is_to_min || is_to_max)) {\n            to_min = this.convertToPercent(is_to_min ? o.to_min : o.min);\n            to_max = this.convertToPercent(is_to_max ? o.to_max : o.max) - to_min;\n            to_min = this.toFixed(to_min - this.coords.p_handle / 100 * to_min);\n            to_max = this.toFixed(to_max - this.coords.p_handle / 100 * to_max);\n            to_min = to_min + this.coords.p_handle / 2;\n            c.shad_to[0].style.display = \"block\";\n            c.shad_to[0].style.left = to_min + \"%\";\n            c.shad_to[0].style.width = to_max + \"%\";\n          } else {\n            c.shad_to[0].style.display = \"none\";\n          }\n        }\n      },\n\n      /**\r\n       * Write values to input element\r\n       */\n      writeToInput: function () {\n        if (this.options.type === \"single\") {\n          if (this.options.values.length) {\n            this.$cache.input.prop(\"value\", this.result.from_value);\n          } else {\n            this.$cache.input.prop(\"value\", this.result.from);\n          }\n\n          this.$cache.input.data(\"from\", this.result.from);\n        } else {\n          if (this.options.values.length) {\n            this.$cache.input.prop(\"value\", this.result.from_value + this.options.input_values_separator + this.result.to_value);\n          } else {\n            this.$cache.input.prop(\"value\", this.result.from + this.options.input_values_separator + this.result.to);\n          }\n\n          this.$cache.input.data(\"from\", this.result.from);\n          this.$cache.input.data(\"to\", this.result.to);\n        }\n      },\n      // =============================================================================================================\n      // Callbacks\n      callOnStart: function () {\n        this.writeToInput();\n\n        if (this.options.onStart && typeof this.options.onStart === \"function\") {\n          if (this.options.scope) {\n            this.options.onStart.call(this.options.scope, this.result);\n          } else {\n            this.options.onStart(this.result);\n          }\n        }\n      },\n      callOnChange: function () {\n        this.writeToInput();\n\n        if (this.options.onChange && typeof this.options.onChange === \"function\") {\n          if (this.options.scope) {\n            this.options.onChange.call(this.options.scope, this.result);\n          } else {\n            this.options.onChange(this.result);\n          }\n        }\n      },\n      callOnFinish: function () {\n        this.writeToInput();\n\n        if (this.options.onFinish && typeof this.options.onFinish === \"function\") {\n          if (this.options.scope) {\n            this.options.onFinish.call(this.options.scope, this.result);\n          } else {\n            this.options.onFinish(this.result);\n          }\n        }\n      },\n      callOnUpdate: function () {\n        this.writeToInput();\n\n        if (this.options.onUpdate && typeof this.options.onUpdate === \"function\") {\n          if (this.options.scope) {\n            this.options.onUpdate.call(this.options.scope, this.result);\n          } else {\n            this.options.onUpdate(this.result);\n          }\n        }\n      },\n      // =============================================================================================================\n      // Service methods\n      toggleInput: function () {\n        this.$cache.input.toggleClass(\"irs-hidden-input\");\n\n        if (this.has_tab_index) {\n          this.$cache.input.prop(\"tabindex\", -1);\n        } else {\n          this.$cache.input.removeProp(\"tabindex\");\n        }\n\n        this.has_tab_index = !this.has_tab_index;\n      },\n\n      /**\r\n       * Convert real value to percent\r\n       *\r\n       * @param value {Number} X in real\r\n       * @param no_min {boolean=} don't use min value\r\n       * @returns {Number} X in percent\r\n       */\n      convertToPercent: function (value, no_min) {\n        var diapason = this.options.max - this.options.min,\n            one_percent = diapason / 100,\n            val,\n            percent;\n\n        if (!diapason) {\n          this.no_diapason = true;\n          return 0;\n        }\n\n        if (no_min) {\n          val = value;\n        } else {\n          val = value - this.options.min;\n        }\n\n        percent = val / one_percent;\n        return this.toFixed(percent);\n      },\n\n      /**\r\n       * Convert percent to real values\r\n       *\r\n       * @param percent {Number} X in percent\r\n       * @returns {Number} X in real\r\n       */\n      convertToValue: function (percent) {\n        var min = this.options.min,\n            max = this.options.max,\n            min_decimals = min.toString().split(\".\")[1],\n            max_decimals = max.toString().split(\".\")[1],\n            min_length,\n            max_length,\n            avg_decimals = 0,\n            abs = 0;\n\n        if (percent === 0) {\n          return this.options.min;\n        }\n\n        if (percent === 100) {\n          return this.options.max;\n        }\n\n        if (min_decimals) {\n          min_length = min_decimals.length;\n          avg_decimals = min_length;\n        }\n\n        if (max_decimals) {\n          max_length = max_decimals.length;\n          avg_decimals = max_length;\n        }\n\n        if (min_length && max_length) {\n          avg_decimals = min_length >= max_length ? min_length : max_length;\n        }\n\n        if (min < 0) {\n          abs = Math.abs(min);\n          min = +(min + abs).toFixed(avg_decimals);\n          max = +(max + abs).toFixed(avg_decimals);\n        }\n\n        var number = (max - min) / 100 * percent + min,\n            string = this.options.step.toString().split(\".\")[1],\n            result;\n\n        if (string) {\n          number = +number.toFixed(string.length);\n        } else {\n          number = number / this.options.step;\n          number = number * this.options.step;\n          number = +number.toFixed(0);\n        }\n\n        if (abs) {\n          number -= abs;\n        }\n\n        if (string) {\n          result = +number.toFixed(string.length);\n        } else {\n          result = this.toFixed(number);\n        }\n\n        if (result < this.options.min) {\n          result = this.options.min;\n        } else if (result > this.options.max) {\n          result = this.options.max;\n        }\n\n        return result;\n      },\n\n      /**\r\n       * Round percent value with step\r\n       *\r\n       * @param percent {Number}\r\n       * @returns percent {Number} rounded\r\n       */\n      calcWithStep: function (percent) {\n        var rounded = Math.round(percent / this.coords.p_step) * this.coords.p_step;\n\n        if (rounded > 100) {\n          rounded = 100;\n        }\n\n        if (percent === 100) {\n          rounded = 100;\n        }\n\n        return this.toFixed(rounded);\n      },\n      checkMinInterval: function (p_current, p_next, type) {\n        var o = this.options,\n            current,\n            next;\n\n        if (!o.min_interval) {\n          return p_current;\n        }\n\n        current = this.convertToValue(p_current);\n        next = this.convertToValue(p_next);\n\n        if (type === \"from\") {\n          if (next - current < o.min_interval) {\n            current = next - o.min_interval;\n          }\n        } else {\n          if (current - next < o.min_interval) {\n            current = next + o.min_interval;\n          }\n        }\n\n        return this.convertToPercent(current);\n      },\n      checkMaxInterval: function (p_current, p_next, type) {\n        var o = this.options,\n            current,\n            next;\n\n        if (!o.max_interval) {\n          return p_current;\n        }\n\n        current = this.convertToValue(p_current);\n        next = this.convertToValue(p_next);\n\n        if (type === \"from\") {\n          if (next - current > o.max_interval) {\n            current = next - o.max_interval;\n          }\n        } else {\n          if (current - next > o.max_interval) {\n            current = next + o.max_interval;\n          }\n        }\n\n        return this.convertToPercent(current);\n      },\n      checkDiapason: function (p_num, min, max) {\n        var num = this.convertToValue(p_num),\n            o = this.options;\n\n        if (typeof min !== \"number\") {\n          min = o.min;\n        }\n\n        if (typeof max !== \"number\") {\n          max = o.max;\n        }\n\n        if (num < min) {\n          num = min;\n        }\n\n        if (num > max) {\n          num = max;\n        }\n\n        return this.convertToPercent(num);\n      },\n      toFixed: function (num) {\n        num = num.toFixed(20);\n        return +num;\n      },\n      _prettify: function (num) {\n        if (!this.options.prettify_enabled) {\n          return num;\n        }\n\n        if (this.options.prettify && typeof this.options.prettify === \"function\") {\n          return this.options.prettify(num);\n        } else {\n          return this.prettify(num);\n        }\n      },\n      prettify: function (num) {\n        var n = num.toString();\n        return n.replace(/(\\d{1,3}(?=(?:\\d\\d\\d)+(?!\\d)))/g, \"$1\" + this.options.prettify_separator);\n      },\n      checkEdges: function (left, width) {\n        if (!this.options.force_edges) {\n          return this.toFixed(left);\n        }\n\n        if (left < 0) {\n          left = 0;\n        } else if (left > 100 - width) {\n          left = 100 - width;\n        }\n\n        return this.toFixed(left);\n      },\n      validate: function () {\n        var o = this.options,\n            r = this.result,\n            v = o.values,\n            vl = v.length,\n            value,\n            i;\n        if (typeof o.min === \"string\") o.min = +o.min;\n        if (typeof o.max === \"string\") o.max = +o.max;\n        if (typeof o.from === \"string\") o.from = +o.from;\n        if (typeof o.to === \"string\") o.to = +o.to;\n        if (typeof o.step === \"string\") o.step = +o.step;\n        if (typeof o.from_min === \"string\") o.from_min = +o.from_min;\n        if (typeof o.from_max === \"string\") o.from_max = +o.from_max;\n        if (typeof o.to_min === \"string\") o.to_min = +o.to_min;\n        if (typeof o.to_max === \"string\") o.to_max = +o.to_max;\n        if (typeof o.grid_num === \"string\") o.grid_num = +o.grid_num;\n\n        if (o.max < o.min) {\n          o.max = o.min;\n        }\n\n        if (vl) {\n          o.p_values = [];\n          o.min = 0;\n          o.max = vl - 1;\n          o.step = 1;\n          o.grid_num = o.max;\n          o.grid_snap = true;\n\n          for (i = 0; i < vl; i++) {\n            value = +v[i];\n\n            if (!isNaN(value)) {\n              v[i] = value;\n              value = this._prettify(value);\n            } else {\n              value = v[i];\n            }\n\n            o.p_values.push(value);\n          }\n        }\n\n        if (typeof o.from !== \"number\" || isNaN(o.from)) {\n          o.from = o.min;\n        }\n\n        if (typeof o.to !== \"number\" || isNaN(o.to)) {\n          o.to = o.max;\n        }\n\n        if (o.type === \"single\") {\n          if (o.from < o.min) o.from = o.min;\n          if (o.from > o.max) o.from = o.max;\n        } else {\n          if (o.from < o.min) o.from = o.min;\n          if (o.from > o.max) o.from = o.max;\n          if (o.to < o.min) o.to = o.min;\n          if (o.to > o.max) o.to = o.max;\n\n          if (this.update_check.from) {\n            if (this.update_check.from !== o.from) {\n              if (o.from > o.to) o.from = o.to;\n            }\n\n            if (this.update_check.to !== o.to) {\n              if (o.to < o.from) o.to = o.from;\n            }\n          }\n\n          if (o.from > o.to) o.from = o.to;\n          if (o.to < o.from) o.to = o.from;\n        }\n\n        if (typeof o.step !== \"number\" || isNaN(o.step) || !o.step || o.step < 0) {\n          o.step = 1;\n        }\n\n        if (typeof o.from_min === \"number\" && o.from < o.from_min) {\n          o.from = o.from_min;\n        }\n\n        if (typeof o.from_max === \"number\" && o.from > o.from_max) {\n          o.from = o.from_max;\n        }\n\n        if (typeof o.to_min === \"number\" && o.to < o.to_min) {\n          o.to = o.to_min;\n        }\n\n        if (typeof o.to_max === \"number\" && o.from > o.to_max) {\n          o.to = o.to_max;\n        }\n\n        if (r) {\n          if (r.min !== o.min) {\n            r.min = o.min;\n          }\n\n          if (r.max !== o.max) {\n            r.max = o.max;\n          }\n\n          if (r.from < r.min || r.from > r.max) {\n            r.from = o.from;\n          }\n\n          if (r.to < r.min || r.to > r.max) {\n            r.to = o.to;\n          }\n        }\n\n        if (typeof o.min_interval !== \"number\" || isNaN(o.min_interval) || !o.min_interval || o.min_interval < 0) {\n          o.min_interval = 0;\n        }\n\n        if (typeof o.max_interval !== \"number\" || isNaN(o.max_interval) || !o.max_interval || o.max_interval < 0) {\n          o.max_interval = 0;\n        }\n\n        if (o.min_interval && o.min_interval > o.max - o.min) {\n          o.min_interval = o.max - o.min;\n        }\n\n        if (o.max_interval && o.max_interval > o.max - o.min) {\n          o.max_interval = o.max - o.min;\n        }\n      },\n      decorate: function (num, original) {\n        var decorated = \"\",\n            o = this.options;\n\n        if (o.prefix) {\n          decorated += o.prefix;\n        }\n\n        decorated += num;\n\n        if (o.max_postfix) {\n          if (o.values.length && num === o.p_values[o.max]) {\n            decorated += o.max_postfix;\n\n            if (o.postfix) {\n              decorated += \" \";\n            }\n          } else if (original === o.max) {\n            decorated += o.max_postfix;\n\n            if (o.postfix) {\n              decorated += \" \";\n            }\n          }\n        }\n\n        if (o.postfix) {\n          decorated += o.postfix;\n        }\n\n        return decorated;\n      },\n      updateFrom: function () {\n        this.result.from = this.options.from;\n        this.result.from_percent = this.convertToPercent(this.result.from);\n        this.result.from_pretty = this._prettify(this.result.from);\n\n        if (this.options.values) {\n          this.result.from_value = this.options.values[this.result.from];\n        }\n      },\n      updateTo: function () {\n        this.result.to = this.options.to;\n        this.result.to_percent = this.convertToPercent(this.result.to);\n        this.result.to_pretty = this._prettify(this.result.to);\n\n        if (this.options.values) {\n          this.result.to_value = this.options.values[this.result.to];\n        }\n      },\n      updateResult: function () {\n        this.result.min = this.options.min;\n        this.result.max = this.options.max;\n        this.updateFrom();\n        this.updateTo();\n      },\n      // =============================================================================================================\n      // Grid\n      appendGrid: function () {\n        if (!this.options.grid) {\n          return;\n        }\n\n        var o = this.options,\n            i,\n            z,\n            total = o.max - o.min,\n            big_num = o.grid_num,\n            big_p = 0,\n            big_w = 0,\n            small_max = 4,\n            local_small_max,\n            small_p,\n            small_w = 0,\n            result,\n            html = '';\n        this.calcGridMargin();\n\n        if (o.grid_snap) {\n          big_num = total / o.step;\n        }\n\n        if (big_num > 50) big_num = 50;\n        big_p = this.toFixed(100 / big_num);\n\n        if (big_num > 4) {\n          small_max = 3;\n        }\n\n        if (big_num > 7) {\n          small_max = 2;\n        }\n\n        if (big_num > 14) {\n          small_max = 1;\n        }\n\n        if (big_num > 28) {\n          small_max = 0;\n        }\n\n        for (i = 0; i < big_num + 1; i++) {\n          local_small_max = small_max;\n          big_w = this.toFixed(big_p * i);\n\n          if (big_w > 100) {\n            big_w = 100;\n          }\n\n          this.coords.big[i] = big_w;\n          small_p = (big_w - big_p * (i - 1)) / (local_small_max + 1);\n\n          for (z = 1; z <= local_small_max; z++) {\n            if (big_w === 0) {\n              break;\n            }\n\n            small_w = this.toFixed(big_w - small_p * z);\n            html += '<span class=\"irs-grid-pol small\" style=\"left: ' + small_w + '%\"></span>';\n          }\n\n          html += '<span class=\"irs-grid-pol\" style=\"left: ' + big_w + '%\"></span>';\n          result = this.convertToValue(big_w);\n\n          if (o.values.length) {\n            result = o.p_values[result];\n          } else {\n            result = this._prettify(result);\n          }\n\n          html += '<span class=\"irs-grid-text js-grid-text-' + i + '\" style=\"left: ' + big_w + '%\">' + result + '</span>';\n        }\n\n        this.coords.big_num = Math.ceil(big_num + 1);\n        this.$cache.cont.addClass(\"irs-with-grid\");\n        this.$cache.grid.html(html);\n        this.cacheGridLabels();\n      },\n      cacheGridLabels: function () {\n        var $label,\n            i,\n            num = this.coords.big_num;\n\n        for (i = 0; i < num; i++) {\n          $label = this.$cache.grid.find(\".js-grid-text-\" + i);\n          this.$cache.grid_labels.push($label);\n        }\n\n        this.calcGridLabels();\n      },\n      calcGridLabels: function () {\n        var i,\n            label,\n            start = [],\n            finish = [],\n            num = this.coords.big_num;\n\n        for (i = 0; i < num; i++) {\n          this.coords.big_w[i] = this.$cache.grid_labels[i].outerWidth(false);\n          this.coords.big_p[i] = this.toFixed(this.coords.big_w[i] / this.coords.w_rs * 100);\n          this.coords.big_x[i] = this.toFixed(this.coords.big_p[i] / 2);\n          start[i] = this.toFixed(this.coords.big[i] - this.coords.big_x[i]);\n          finish[i] = this.toFixed(start[i] + this.coords.big_p[i]);\n        }\n\n        if (this.options.force_edges) {\n          if (start[0] < -this.coords.grid_gap) {\n            start[0] = -this.coords.grid_gap;\n            finish[0] = this.toFixed(start[0] + this.coords.big_p[0]);\n            this.coords.big_x[0] = this.coords.grid_gap;\n          }\n\n          if (finish[num - 1] > 100 + this.coords.grid_gap) {\n            finish[num - 1] = 100 + this.coords.grid_gap;\n            start[num - 1] = this.toFixed(finish[num - 1] - this.coords.big_p[num - 1]);\n            this.coords.big_x[num - 1] = this.toFixed(this.coords.big_p[num - 1] - this.coords.grid_gap);\n          }\n        }\n\n        this.calcGridCollision(2, start, finish);\n        this.calcGridCollision(4, start, finish);\n\n        for (i = 0; i < num; i++) {\n          label = this.$cache.grid_labels[i][0];\n\n          if (this.coords.big_x[i] !== Number.POSITIVE_INFINITY) {\n            label.style.marginLeft = -this.coords.big_x[i] + \"%\";\n          }\n        }\n      },\n      // Collisions Calc Beta\n      // TODO: Refactor then have plenty of time\n      calcGridCollision: function (step, start, finish) {\n        var i,\n            next_i,\n            label,\n            num = this.coords.big_num;\n\n        for (i = 0; i < num; i += step) {\n          next_i = i + step / 2;\n\n          if (next_i >= num) {\n            break;\n          }\n\n          label = this.$cache.grid_labels[next_i][0];\n\n          if (finish[i] <= start[next_i]) {\n            label.style.visibility = \"visible\";\n          } else {\n            label.style.visibility = \"hidden\";\n          }\n        }\n      },\n      calcGridMargin: function () {\n        if (!this.options.grid_margin) {\n          return;\n        }\n\n        this.coords.w_rs = this.$cache.rs.outerWidth(false);\n\n        if (!this.coords.w_rs) {\n          return;\n        }\n\n        if (this.options.type === \"single\") {\n          this.coords.w_handle = this.$cache.s_single.outerWidth(false);\n        } else {\n          this.coords.w_handle = this.$cache.s_from.outerWidth(false);\n        }\n\n        this.coords.p_handle = this.toFixed(this.coords.w_handle / this.coords.w_rs * 100);\n        this.coords.grid_gap = this.toFixed(this.coords.p_handle / 2 - 0.1);\n        this.$cache.grid[0].style.width = this.toFixed(100 - this.coords.p_handle) + \"%\";\n        this.$cache.grid[0].style.left = this.coords.grid_gap + \"%\";\n      },\n      // =============================================================================================================\n      // Public methods\n      update: function (options) {\n        if (!this.input) {\n          return;\n        }\n\n        this.is_update = true;\n        this.options.from = this.result.from;\n        this.options.to = this.result.to;\n        this.update_check.from = this.result.from;\n        this.update_check.to = this.result.to;\n        this.options = $.extend(this.options, options);\n        this.validate();\n        this.updateResult(options);\n        this.toggleInput();\n        this.remove();\n        this.init(true);\n      },\n      reset: function () {\n        if (!this.input) {\n          return;\n        }\n\n        this.updateResult();\n        this.update();\n      },\n      destroy: function () {\n        if (!this.input) {\n          return;\n        }\n\n        this.toggleInput();\n        this.$cache.input.prop(\"readonly\", false);\n        $.data(this.input, \"ionRangeSlider\", null);\n        this.remove();\n        this.input = null;\n        this.options = null;\n      }\n    };\n\n    $.fn.ionRangeSlider = function (options) {\n      return this.each(function () {\n        if (!$.data(this, \"ionRangeSlider\")) {\n          $.data(this, \"ionRangeSlider\", new IonRangeSlider(this, options, plugin_count++));\n        }\n      });\n    }; // =================================================================================================================\n    // http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n    // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n    // requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel\n    // MIT license\n\n\n    (function () {\n      var lastTime = 0;\n      var vendors = ['ms', 'moz', 'webkit', 'o'];\n\n      for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n      }\n\n      if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {\n        var currTime = new Date().getTime();\n        var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n        var id = window.setTimeout(function () {\n          callback(currTime + timeToCall);\n        }, timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n      };\n      if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {\n        clearTimeout(id);\n      };\n    })();\n  });\n});\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar IonRangeSlider = function (_Component) {\n  inherits(IonRangeSlider, _Component);\n\n  function IonRangeSlider(props) {\n    classCallCheck(this, IonRangeSlider);\n\n    var _this = possibleConstructorReturn(this, (IonRangeSlider.__proto__ || Object.getPrototypeOf(IonRangeSlider)).call(this, props));\n\n    _initialiseProps.call(_this);\n\n    _this.ref = React.createRef();\n    return _this;\n  }\n\n  createClass(IonRangeSlider, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var props = this.props;\n\n      var options = function (_ref) {\n        var style = _ref.style,\n            className = _ref.className,\n            key = _ref.key,\n            id = _ref.id,\n            others = objectWithoutProperties(_ref, ['style', 'className', 'key', 'id']);\n        return _extends({}, others);\n      }(props);\n\n      $(this.ref).ionRangeSlider(options);\n      this.ionSliderRange = $(this.ref).data('ionRangeSlider');\n    }\n  }, {\n    key: 'shouldComponentUpdate',\n    value: function shouldComponentUpdate(nextProps, nextState, nextContext) {\n      if (this.props !== nextProps) {\n        this.ionSliderRange.update(_extends({}, this.props, nextProps));\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      return React.createElement('input', {\n        ref: function ref(node) {\n          _this2.ref = node;\n        }\n      });\n    }\n  }]);\n  return IonRangeSlider;\n}(Component);\n\nIonRangeSlider.defaultProps = {\n  type: 'single',\n  skin: 'flat'\n};\nIonRangeSlider.propTypes = {\n  /* Basic setup */\n  type: PropTypes.string,\n  min: PropTypes.number,\n  max: PropTypes.number,\n  from: PropTypes.number,\n  to: PropTypes.number,\n\n  /* Advanced setup */\n  step: PropTypes.number,\n  values: PropTypes.array,\n  keyboard: PropTypes.bool,\n\n  /* Grid setup */\n  grid: PropTypes.bool,\n  grid_margin: PropTypes.bool,\n  grid_num: PropTypes.number,\n  grid_snap: PropTypes.bool,\n\n  /* Interval control */\n  drag_interval: PropTypes.bool,\n  min_interval: PropTypes.number,\n  max_interval: PropTypes.number,\n\n  /* Handles control */\n  from_fixed: PropTypes.bool,\n  from_min: PropTypes.number,\n  from_max: PropTypes.number,\n  from_shadow: PropTypes.bool,\n  to_fixed: PropTypes.bool,\n  to_min: PropTypes.number,\n  to_max: PropTypes.number,\n  to_shadow: PropTypes.bool,\n\n  /* UI control */\n  skin: PropTypes.string,\n  hide_min_max: PropTypes.bool,\n  hide_from_to: PropTypes.bool,\n  force_edges: PropTypes.bool,\n  extra_classes: PropTypes.string,\n  block: PropTypes.bool,\n\n  /* Prettify numbers */\n  prettify_enabled: PropTypes.bool,\n  prettify_separator: PropTypes.string,\n  prettify: PropTypes.func,\n  prefix: PropTypes.string,\n  postfix: PropTypes.string,\n  max_postfix: PropTypes.string,\n  decorate_both: PropTypes.bool,\n  value_separator: PropTypes.string,\n\n  /* Data control */\n  input_values_separator: PropTypes.string,\n  disable: PropTypes.bool,\n\n  /* Callbacks */\n  scope: PropTypes.object,\n  onStart: PropTypes.func,\n  onChange: PropTypes.func,\n  onFinish: PropTypes.func,\n  onUpdate: PropTypes.func\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this3 = this;\n\n  this.update = function (_options) {\n    var props = _this3.props;\n\n    var options = function (_ref2) {\n      var style = _ref2.style,\n          className = _ref2.className,\n          key = _ref2.key,\n          id = _ref2.id,\n          others = objectWithoutProperties(_ref2, ['style', 'className', 'key', 'id']);\n      return _extends({}, others);\n    }(props);\n\n    _this3.ionSliderRange && _this3.ionSliderRange.update(_options || options);\n  };\n};\n\nIonRangeSlider.propTypes = {\n  /* Basic setup */\n  type: PropTypes.string,\n  min: PropTypes.number,\n  max: PropTypes.number,\n  from: PropTypes.number,\n  to: PropTypes.number,\n\n  /* Advanced setup */\n  step: PropTypes.number,\n  values: PropTypes.array,\n  keyboard: PropTypes.bool,\n\n  /* Grid setup */\n  grid: PropTypes.bool,\n  grid_margin: PropTypes.bool,\n  grid_num: PropTypes.number,\n  grid_snap: PropTypes.bool,\n\n  /* Interval control */\n  drag_interval: PropTypes.bool,\n  min_interval: PropTypes.number,\n  max_interval: PropTypes.number,\n\n  /* Handles control */\n  from_fixed: PropTypes.bool,\n  from_min: PropTypes.number,\n  from_max: PropTypes.number,\n  from_shadow: PropTypes.bool,\n  to_fixed: PropTypes.bool,\n  to_min: PropTypes.number,\n  to_max: PropTypes.number,\n  to_shadow: PropTypes.bool,\n\n  /* UI control */\n  skin: PropTypes.string,\n  hide_min_max: PropTypes.bool,\n  hide_from_to: PropTypes.bool,\n  force_edges: PropTypes.bool,\n  extra_classes: PropTypes.string,\n  block: PropTypes.bool,\n\n  /* Prettify numbers */\n  prettify_enabled: PropTypes.bool,\n  prettify_separator: PropTypes.string,\n  prettify: PropTypes.func,\n  prefix: PropTypes.string,\n  postfix: PropTypes.string,\n  max_postfix: PropTypes.string,\n  decorate_both: PropTypes.bool,\n  value_separator: PropTypes.string,\n\n  /* Data control */\n  input_values_separator: PropTypes.string,\n  disable: PropTypes.bool,\n\n  /* Callbacks */\n  scope: PropTypes.object,\n  onStart: PropTypes.func,\n  onChange: PropTypes.func,\n  onFinish: PropTypes.func,\n  onUpdate: PropTypes.func\n};\nexport default IonRangeSlider;","map":null,"metadata":{},"sourceType":"module"}