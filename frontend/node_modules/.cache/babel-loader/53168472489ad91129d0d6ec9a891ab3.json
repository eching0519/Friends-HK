{"ast":null,"code":"import _slicedToArray from \"Z:\\\\3100project\\\\Friends-HK\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n\n/**\r\n * Bootstrap 5 (and 4!) tags\r\n *\r\n * Turns your select[multiple] into nice tags lists\r\n *\r\n * Required Bootstrap 5 styles:\r\n * - badge\r\n * - background-color utility\r\n * - margin-end utility\r\n * - float-start utility\r\n * - forms\r\n * - dropdown\r\n */\nconst ACTIVE_CLASS = \"is-active\";\nconst ACTIVE_CLASSES = [\"is-active\", \"bg-primary\", \"text-white\"];\nconst VALUE_ATTRIBUTE = \"data-value\"; // Static map will minify very badly as class prop, so we use an external constant\n\nconst INSTANCE_MAP = new WeakMap();\n\nclass Tags {\n  /**\r\n   * @param {HTMLSelectElement} el\r\n   * @param {Object} globalOpts\r\n   */\n  constructor(el, globalOpts = {}) {\n    // Hide the select element and register a tags attr\n    el.style.display = \"none\";\n    INSTANCE_MAP.set(el, this);\n    this._selectElement = el; // Allow 1/0, true/false as strings\n\n    const parseBool = value => [\"true\", \"false\", \"1\", \"0\", true, false].includes(value) && !!JSON.parse(value); // Handle options, using global settings first and data attr override\n\n\n    const opts = { ...globalOpts,\n      ...el.dataset\n    };\n    this.allowNew = opts.allowNew ? parseBool(opts.allowNew) : false;\n    this.showAllSuggestions = opts.showAllSuggestions ? parseBool(opts.showAllSuggestions) : false;\n    this.badgeStyle = opts.badgeStyle || \"primary\";\n    this.allowClear = opts.allowClear ? parseBool(opts.allowClear) : false;\n    this.server = opts.server || false;\n    this.liveServer = opts.liveServer ? parseBool(opts.liveServer) : false;\n    this.serverParams = opts.serverParams || {};\n\n    if (typeof this.serverParams == \"string\") {\n      this.serverParams = JSON.parse(this.serverParams);\n    }\n\n    this.suggestionsThreshold = typeof opts.suggestionsThreshold != \"undefined\" ? parseInt(opts.suggestionsThreshold) : 1;\n    this.validationRegex = opts.regex || \"\";\n    this.separator = opts.separator ? opts.separator.split(\"|\") : [];\n    this.max = opts.max ? parseInt(opts.max) : null;\n    this.clearLabel = opts.clearLabel || \"Clear\";\n    this.searchLabel = opts.searchLabel || \"Type a value\";\n    this.valueField = opts.valueField || \"value\";\n    this.labelField = opts.labelField || \"label\";\n    this.keepOpen = opts.keepOpen ? parseBool(opts.keepOpen) : false;\n    this.fullWidth = opts.fullWidth ? parseBool(opts.fullWidth) : false;\n    this.debounceTime = opts.debounceTime ? parseInt(opts.debounceTime) : 300;\n    this.placeholder = opts.placeholder || this._getPlaceholder();\n    this._keyboardNavigation = false;\n    this._fireEvents = true;\n    this._searchFunc = Tags.debounce(() => {\n      this._loadFromServer(true);\n    }, this.debounceTime);\n    this.overflowParent = null;\n    this.parentForm = el.parentElement;\n\n    while (this.parentForm) {\n      if (this.parentForm.style.overflow === \"hidden\") {\n        this.overflowParent = this.parentForm;\n      }\n\n      this.parentForm = this.parentForm.parentElement;\n\n      if (this.parentForm && this.parentForm.nodeName == \"FORM\") {\n        break;\n      }\n    }\n\n    this.reset = this.reset.bind(this);\n\n    if (this.parentForm) {\n      this.parentForm.addEventListener(\"reset\", this.reset);\n    } // Create elements\n\n\n    this._holderElement = document.createElement(\"div\"); // this is the one holding the fake input and the dropmenu\n\n    this._containerElement = document.createElement(\"div\"); // this is the one for the fake input (labels + input)\n\n    this._dropElement = document.createElement(\"ul\");\n    this._searchInput = document.createElement(\"input\");\n\n    this._holderElement.appendChild(this._containerElement);\n\n    this._containerElement.appendChild(this._searchInput);\n\n    this._holderElement.appendChild(this._dropElement); // insert after select\n\n\n    this._selectElement.parentNode.insertBefore(this._holderElement, this._selectElement.nextSibling); // Configure them\n\n\n    this._configureHolderElement();\n\n    this._configureDropElement();\n\n    this._configureContainerElement();\n\n    this._configureSearchInput();\n\n    this.resetState();\n\n    if (this.server && !this.liveServer) {\n      this._loadFromServer();\n    } else {\n      this.resetSuggestions();\n    }\n  }\n  /**\r\n   * Attach to all elements matched by the selector\r\n   * @param {string} selector\r\n   * @param {Object} opts\r\n   */\n\n\n  static init(selector = \"select[multiple]\", opts = {}) {\n    let list = document.querySelectorAll(selector);\n\n    for (let i = 0; i < list.length; i++) {\n      if (Tags.getInstance(list[i])) {\n        continue;\n      }\n\n      new Tags(list[i], opts);\n    }\n  }\n  /**\r\n   * @param {HTMLSelectElement} el\r\n   */\n\n\n  static getInstance(el) {\n    if (INSTANCE_MAP.has(el)) {\n      return INSTANCE_MAP.get(el);\n    }\n  }\n  /**\r\n   * @param {Function} func\r\n   * @param {number} timeout\r\n   * @returns {Function}\r\n   */\n\n\n  static debounce(func, timeout = 300) {\n    let timer;\n    return (...args) => {\n      clearTimeout(timer);\n      timer = setTimeout(() => {\n        func.apply(this, args);\n      }, timeout);\n    };\n  }\n\n  dispose() {\n    INSTANCE_MAP.delete(this._selectElement);\n    this._selectElement.style.display = \"block\";\n\n    this._holderElement.parentNode.removeChild(this._holderElement);\n\n    if (this.parentForm) {\n      this.parentForm.removeEventListener(\"reset\", this.reset);\n    }\n  }\n\n  resetState() {\n    if (this.isDisabled()) {\n      this._holderElement.setAttribute(\"readonly\", \"\");\n\n      this._searchInput.setAttribute(\"disabled\", \"\");\n    } else {\n      if (this._holderElement.hasAttribute(\"readonly\")) {\n        this._holderElement.removeAttribute(\"readonly\");\n      }\n\n      if (this._searchInput.hasAttribute(\"disabled\")) {\n        this._searchInput.removeAttribute(\"disabled\");\n      }\n    }\n  }\n\n  resetSuggestions() {\n    let suggestions = Array.from(this._selectElement.querySelectorAll(\"option\")).filter(option => {\n      return !option.disabled;\n    }).map(option => {\n      return {\n        value: option.getAttribute(\"value\"),\n        label: option.textContent\n      };\n    });\n\n    this._buildSuggestions(suggestions);\n  }\n  /**\r\n   * @param {boolean} show\r\n   */\n\n\n  _loadFromServer(show = false) {\n    if (this._abortController) {\n      this._abortController.abort();\n    }\n\n    this._abortController = new AbortController();\n    this.serverParams.query = this._searchInput.value;\n    const params = new URLSearchParams(this.serverParams).toString();\n    fetch(this.server + \"?\" + params, {\n      signal: this._abortController.signal\n    }).then(r => r.json()).then(suggestions => {\n      let data = suggestions.data || suggestions;\n\n      this._buildSuggestions(data);\n\n      this._abortController = null;\n\n      if (show) {\n        this._showSuggestions();\n      }\n    }).catch(e => {\n      if (e.name === \"AbortError\") {\n        return;\n      }\n\n      console.error(e);\n    });\n  }\n  /**\r\n   * @returns {string}\r\n   */\n\n\n  _getPlaceholder() {\n    // Use placeholder and data-placeholder in priority\n    if (this._selectElement.hasAttribute(\"placeholder\")) {\n      return this._selectElement.getAttribute(\"placeholder\");\n    }\n\n    if (this._selectElement.dataset.placeholder) {\n      return this._selectElement.dataset.placeholder;\n    } // Fallback to first option if no value\n\n\n    let firstOption = this._selectElement.querySelector(\"option\");\n\n    if (!firstOption) {\n      return \"\";\n    }\n\n    if (firstOption.hasAttribute(\"selected\")) {\n      firstOption.removeAttribute(\"selected\");\n    }\n\n    return !firstOption.value ? firstOption.textContent : \"\";\n  }\n\n  _configureDropElement() {\n    this._dropElement.classList.add(...[\"dropdown-menu\", \"p-0\"]);\n\n    this._dropElement.style.maxHeight = \"280px\";\n\n    if (!this.fullWidth) {\n      this._dropElement.style.maxWidth = \"360px\";\n    }\n\n    this._dropElement.style.overflowY = \"auto\"; // If the mouse was outside, entering remove keyboard nav mode\n\n    this._dropElement.addEventListener(\"mouseenter\", event => {\n      this._keyboardNavigation = false;\n    });\n  }\n\n  _configureHolderElement() {\n    this._holderElement.classList.add(...[\"form-control\", \"dropdown\"]); // If we don't have an overflow parent, we can simply inherit styles\n    // If we have an overflow parent, it needs a relatively positioned element\n\n\n    if (this.overflowParent) {\n      this._holderElement.style.position = \"inherit\";\n    }\n\n    if (this._getBootstrapVersion() === 4) {\n      // Prevent fixed height due to form-control\n      this._holderElement.style.height = \"auto\";\n    }\n  }\n\n  _configureContainerElement() {\n    this._containerElement.addEventListener(\"click\", event => {\n      if (this.isDisabled()) {\n        return;\n      }\n\n      if (this._searchInput.style.visibility != \"hidden\") {\n        this._searchInput.focus();\n      }\n    }); // add initial values\n    // we use selectedOptions because single select can have a selected option\n    // without a selected attribute if it's the first value\n\n\n    let initialValues = this._selectElement.selectedOptions;\n\n    for (let j = 0; j < initialValues.length; j++) {\n      let initialValue = initialValues[j];\n\n      if (!initialValue.value) {\n        continue;\n      } // track initial values for reset\n\n\n      initialValue.dataset.init = 1;\n      this.addItem(initialValue.textContent, initialValue.value);\n    }\n  }\n\n  _configureSearchInput() {\n    this._searchInput.type = \"text\";\n    this._searchInput.autocomplete = \"off\";\n    this._searchInput.spellcheck = false;\n    this._searchInput.style.backgroundColor = \"transparent\";\n    this._searchInput.style.border = 0;\n    this._searchInput.style.outline = 0;\n    this._searchInput.style.maxWidth = \"100%\";\n    this._searchInput.ariaLabel = this.searchLabel;\n\n    this._resetSearchInput(true);\n\n    this._searchInput.addEventListener(\"input\", event => {\n      // Add item if a separator is used\n      // On mobile or copy paste, it can pass multiple chars (eg: when pressing space and it formats the string)\n      if (event.data) {\n        const lastChar = event.data.slice(-1);\n\n        if (this.separator.length && this._searchInput.value && this.separator.includes(lastChar)) {\n          // Remove separator even if adding is prevented\n          this._searchInput.value = this._searchInput.value.slice(0, -1);\n          let text = this._searchInput.value;\n\n          this._add(text, null);\n\n          return;\n        }\n      } // Adjust input width to current content\n\n\n      this._adjustWidth(); // Check if we should display suggestions\n\n\n      if (this._searchInput.value.length >= this.suggestionsThreshold) {\n        if (this.liveServer) {\n          this._searchFunc();\n        } else {\n          this._showSuggestions();\n        }\n      } else {\n        this._hideSuggestions();\n      }\n    });\n\n    this._searchInput.addEventListener(\"focus\", event => {\n      if (this._searchInput.value.length >= this.suggestionsThreshold) {\n        this._showSuggestions();\n      }\n    });\n\n    this._searchInput.addEventListener(\"focusout\", event => {\n      this._hideSuggestions();\n\n      if (this.keepOpen) {\n        this._resetSearchInput();\n      }\n    }); // keypress doesn't send arrow keys, so we use keydown\n\n\n    this._searchInput.addEventListener(\"keydown\", event => {\n      // Keycode reference : https://css-tricks.com/snippets/javascript/javascript-keycodes/\n      let key = event.keyCode || event.key; // Keyboard keys\n\n      switch (key) {\n        case 13:\n        case \"Enter\":\n          event.preventDefault();\n          let selection = this.getActiveSelection();\n\n          if (selection) {\n            selection.click();\n          } else {\n            // We use what is typed if not selected and not empty\n            if (this.allowNew && this._searchInput.value) {\n              let text = this._searchInput.value;\n\n              this._add(text, null);\n            }\n          }\n\n          break;\n\n        case 38:\n        case \"ArrowUp\":\n          event.preventDefault();\n          this._keyboardNavigation = true;\n\n          let newSelection = this._moveSelectionUp(); // If we use arrow up without input and there is no new selection, hide suggestions\n\n\n          if (this._searchInput.value.length == 0 && this._dropElement.classList.contains(\"show\") && !newSelection) {\n            this._hideSuggestions();\n          }\n\n          break;\n\n        case 40:\n        case \"ArrowDown\":\n          event.preventDefault();\n          this._keyboardNavigation = true;\n\n          this._moveSelectionDown(); // If we use arrow down without input, show suggestions\n\n\n          if (this._searchInput.value.length == 0 && !this._dropElement.classList.contains(\"show\")) {\n            this._showSuggestions();\n          }\n\n          break;\n\n        case 8:\n        case \"Backspace\":\n          if (this._searchInput.value.length == 0) {\n            this.removeLastItem();\n\n            this._adjustWidth();\n\n            this._hideSuggestions();\n          }\n\n          break;\n\n        case 27:\n        case \"Escape\":\n          // We may wish to not use the suggestions\n          this._hideSuggestions();\n\n          break;\n      }\n    });\n  }\n  /**\r\n   * @param {string} text\r\n   * @param {string} value\r\n   * @param {object} data\r\n   */\n\n\n  _add(text, value = null, data = {}) {\n    if (!this.canAdd(text, value)) {\n      return;\n    }\n\n    this.addItem(text, value, data);\n\n    if (this.keepOpen) {\n      this._showSuggestions();\n    } else {\n      this._resetSearchInput();\n    }\n  }\n  /**\r\n   * @returns {HTMLElement}\r\n   */\n\n\n  _moveSelectionUp() {\n    let active = this.getActiveSelection();\n\n    if (active) {\n      let prev = active.parentNode;\n\n      do {\n        prev = prev.previousSibling;\n      } while (prev && prev.style.display == \"none\");\n\n      if (!prev) {\n        return null;\n      }\n\n      active.classList.remove(...ACTIVE_CLASSES);\n      prev.querySelector(\"a\").classList.add(...ACTIVE_CLASSES); // Don't use scrollIntoView as it scrolls the whole window\n\n      prev.parentNode.scrollTop = prev.offsetTop - prev.parentNode.offsetTop;\n      return prev;\n    }\n\n    return null;\n  }\n  /**\r\n   * @returns {HTMLElement}\r\n   */\n\n\n  _moveSelectionDown() {\n    let active = this.getActiveSelection();\n    let next = null;\n\n    if (active) {\n      next = active.parentNode;\n\n      do {\n        next = next.nextSibling;\n      } while (next && next.style.display == \"none\");\n\n      if (!next) {\n        return null;\n      }\n\n      active.classList.remove(...ACTIVE_CLASSES);\n      next.querySelector(\"a\").classList.add(...ACTIVE_CLASSES); // This is the equivalent of scrollIntoView(false) but only for parent node\n\n      if (next.offsetTop > next.parentNode.offsetHeight - next.offsetHeight) {\n        next.parentNode.scrollTop += next.offsetHeight;\n      }\n\n      return next;\n    }\n\n    return next;\n  }\n  /**\r\n   * Adjust the field to fit its content and show/hide placeholder if needed\r\n   */\n\n\n  _adjustWidth() {\n    if (this._searchInput.value) {\n      this._searchInput.size = this._searchInput.value.length + 1;\n    } else {\n      // Show the placeholder only if empty\n      if (this.getSelectedValues().length) {\n        this._searchInput.placeholder = \"\";\n        this._searchInput.size = 1;\n      } else {\n        this._searchInput.size = this.placeholder.length > 0 ? this.placeholder.length : 1;\n        this._searchInput.placeholder = this.placeholder;\n      }\n    }\n  }\n  /**\r\n   * Add suggestions to the drop element\r\n   * @param {array}\r\n   */\n\n\n  _buildSuggestions(suggestions = null) {\n    while (this._dropElement.lastChild) {\n      this._dropElement.removeChild(this._dropElement.lastChild);\n    }\n\n    for (let i = 0; i < suggestions.length; i++) {\n      let suggestion = suggestions[i];\n\n      if (!suggestion[this.valueField]) {\n        continue;\n      }\n\n      let newChild = document.createElement(\"li\");\n      let newChildLink = document.createElement(\"a\");\n      newChild.append(newChildLink);\n      newChildLink.classList.add(...[\"dropdown-item\", \"text-truncate\"]);\n      newChildLink.setAttribute(VALUE_ATTRIBUTE, suggestion[this.valueField]);\n      newChildLink.setAttribute(\"href\", \"#\");\n      newChildLink.textContent = suggestion[this.labelField];\n\n      if (suggestion.data) {\n        for (const _ref of Object.entries(suggestion.data)) {\n          var _ref2 = _slicedToArray(_ref, 2);\n\n          const key = _ref2[0];\n          const value = _ref2[1];\n          newChildLink.dataset[key] = value;\n        }\n      }\n\n      this._dropElement.appendChild(newChild); // Hover sets active item\n\n\n      newChildLink.addEventListener(\"mouseenter\", event => {\n        // Don't trigger enter if using arrows\n        if (this._keyboardNavigation) {\n          return;\n        }\n\n        this.removeActiveSelection();\n        newChild.querySelector(\"a\").classList.add(...ACTIVE_CLASSES);\n      }); // Moving the mouse means no longer using keyboard\n\n      newChildLink.addEventListener(\"mousemove\", event => {\n        this._keyboardNavigation = false;\n      });\n      newChildLink.addEventListener(\"mousedown\", event => {\n        // Otherwise searchInput would lose focus and close the menu\n        event.preventDefault();\n      });\n      newChildLink.addEventListener(\"click\", event => {\n        event.preventDefault();\n        let text = newChildLink.textContent;\n\n        this._add(text, newChildLink.getAttribute(VALUE_ATTRIBUTE), newChildLink.dataset);\n      });\n    }\n  }\n\n  reset() {\n    this.removeAll(); // Reset doesn't fire change event\n\n    this._fireEvents = false;\n\n    let initialValues = this._selectElement.querySelectorAll(\"option[data-init]\");\n\n    for (let j = 0; j < initialValues.length; j++) {\n      let initialValue = initialValues[j];\n      this.addItem(initialValue.textContent, initialValue.value);\n    }\n\n    this._adjustWidth();\n\n    this._fireEvents = true;\n  }\n  /**\r\n   * @param {bool} init Pass true during init\r\n   */\n\n\n  _resetSearchInput(init = false) {\n    this._searchInput.value = \"\";\n\n    this._adjustWidth();\n\n    if (!init) {\n      this._hideSuggestions(); // Trigger input even to show suggestions if needed\n\n\n      this._searchInput.dispatchEvent(new Event(\"input\"));\n    } // We use visibility instead of display to keep layout intact\n\n\n    if (this.max && this.getSelectedValues().length === this.max) {\n      this._searchInput.style.visibility = \"hidden\";\n    } else if (this._searchInput.style.visibility == \"hidden\") {\n      this._searchInput.style.visibility = \"visible\";\n    }\n\n    if (this.isSingle() && !init) {\n      document.activeElement.blur();\n    }\n  }\n  /**\r\n   * @returns {array}\r\n   */\n\n\n  getSelectedValues() {\n    // option[selected] is used rather that selectedOptions as it works more consistently\n    let selected = this._selectElement.querySelectorAll(\"option[selected]\");\n\n    return Array.from(selected).map(el => el.value);\n  }\n  /**\r\n   * The element create with buildSuggestions\r\n   */\n\n\n  _showSuggestions() {\n    if (this._searchInput.style.visibility == \"hidden\") {\n      return;\n    } // Get search value\n\n\n    let search = this._searchInput.value.toLocaleLowerCase(); // Get current values\n\n\n    let values = this.getSelectedValues(); // Filter the list according to search string\n\n    let list = this._dropElement.querySelectorAll(\"li\");\n\n    let found = false;\n    let firstItem = null;\n    let hasPossibleValues = false;\n\n    for (let i = 0; i < list.length; i++) {\n      let item = list[i];\n      let text = item.textContent.toLocaleLowerCase();\n      let link = item.querySelector(\"a\"); // Remove previous selection\n\n      link.classList.remove(...ACTIVE_CLASSES); // Hide selected values\n\n      if (values.indexOf(link.getAttribute(VALUE_ATTRIBUTE)) != -1) {\n        item.style.display = \"none\";\n        continue;\n      }\n\n      hasPossibleValues = true; // Check search length since we can trigger dropdown with arrow\n\n      let isMatched = search.length === 0 || text.indexOf(search) !== -1;\n\n      if (this.showAllSuggestions || this.suggestionsThreshold === 0 || isMatched) {\n        item.style.display = \"list-item\";\n        found = true;\n\n        if (!firstItem && isMatched) {\n          firstItem = item;\n        }\n      } else {\n        item.style.display = \"none\";\n      }\n    } // Always select first item\n\n\n    if (firstItem) {\n      this._holderElement.classList.remove(\"is-invalid\");\n\n      firstItem.querySelector(\"a\").classList.add(...ACTIVE_CLASSES);\n      firstItem.parentNode.scrollTop = firstItem.offsetTop;\n    } else {\n      // No item and we don't allow new items => error\n      if (!this.allowNew && !(search.length === 0 && !hasPossibleValues)) {\n        this._holderElement.classList.add(\"is-invalid\");\n      } else if (this.validationRegex && this.isInvalid()) {\n        this._holderElement.classList.remove(\"is-invalid\");\n      }\n    } // Remove dropdown if not found or to show validation message\n\n\n    if (!found || this.isInvalid()) {\n      this._dropElement.classList.remove(\"show\");\n    } else {\n      // Or show it if necessary\n      this._dropElement.classList.add(\"show\");\n\n      if (this.fullWidth) {\n        // Use full input width\n        this._dropElement.style.left = -1 + \"px\";\n        this._dropElement.style.width = this._holderElement.offsetWidth + \"px\";\n      } else {\n        // Position next to search input\n        let left = this._searchInput.offsetLeft; // Overflow right\n\n        const w = document.body.offsetWidth - 1; // avoid rounding issues\n\n        const scrollbarOffset = 30; // scrollbars are not taken into account\n\n        const wdiff = w - (left + this._dropElement.offsetWidth) - scrollbarOffset; // If the dropdowns goes out of the viewport, remove the diff from the left position\n\n        if (wdiff < 0) {\n          left = left + wdiff;\n        }\n\n        this._dropElement.style.left = left + \"px\"; // Overflow bottom\n\n        const h = document.body.offsetHeight;\n\n        let bottom = this._searchInput.getBoundingClientRect().y + window.pageYOffset + this._dropElement.offsetHeight;\n\n        const hdiff = h - bottom;\n\n        if (hdiff < 0) {\n          // We display above input\n          this._dropElement.style.transform = \"translateY(calc(-100% - \" + scrollbarOffset + \"px))\";\n        } else {\n          this._dropElement.style.transform = \"none\";\n        }\n      }\n    }\n  }\n  /**\r\n   * The element create with buildSuggestions\r\n   */\n\n\n  _hideSuggestions() {\n    this._dropElement.classList.remove(\"show\");\n\n    this._holderElement.classList.remove(\"is-invalid\");\n\n    this.removeActiveSelection();\n  }\n  /**\r\n   * @returns {Number}\r\n   */\n\n\n  _getBootstrapVersion() {\n    let ver = 5; // If we have jQuery and the tooltip plugin for BS4\n\n    if (window.jQuery && $.fn.tooltip != undefined && $.fn.tooltip.Constructor != undefined) {\n      ver = parseInt($.fn.tooltip.Constructor.VERSION.charAt(0));\n    }\n\n    return ver;\n  }\n  /**\r\n   * Find if label is already selected (based on attribute)\r\n   * @param {string} text\r\n   * @returns {boolean}\r\n   */\n\n\n  _isSelected(text) {\n    const opt = Array.from(this._selectElement.querySelectorAll(\"option\")).find(el => el.textContent == text);\n\n    if (opt && opt.getAttribute(\"selected\")) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\r\n   * Checks if value matches a configured regex\r\n   * @param {string} value\r\n   * @returns {boolean}\r\n   */\n\n\n  _validateRegex(value) {\n    const regex = new RegExp(this.validationRegex.trim());\n    return regex.test(value);\n  }\n  /**\r\n   * @returns {HTMLElement}\r\n   */\n\n\n  getActiveSelection() {\n    return this._dropElement.querySelector(\"a.\" + ACTIVE_CLASS);\n  }\n\n  removeActiveSelection() {\n    let selection = this.getActiveSelection();\n\n    if (selection) {\n      selection.classList.remove(...ACTIVE_CLASSES);\n    }\n  }\n\n  removeAll() {\n    let items = this.getSelectedValues();\n    items.forEach(item => {\n      this.removeItem(item, true);\n    });\n\n    this._adjustWidth();\n  }\n  /**\r\n   * @param {boolean} noEvents\r\n   */\n\n\n  removeLastItem(noEvents) {\n    let items = this._containerElement.querySelectorAll(\"span\");\n\n    if (!items.length) {\n      return;\n    }\n\n    let lastItem = items[items.length - 1];\n    this.removeItem(lastItem.getAttribute(VALUE_ATTRIBUTE), noEvents);\n  }\n  /**\r\n   * @returns {boolean}\r\n   */\n\n\n  isDisabled() {\n    return this._selectElement.hasAttribute(\"disabled\") || this._selectElement.disabled || this._selectElement.hasAttribute(\"readonly\");\n  }\n  /**\r\n   * @returns {boolean}\r\n   */\n\n\n  isInvalid() {\n    return this._holderElement.classList.contains(\"is-invalid\");\n  }\n  /**\r\n   * @returns {boolean}\r\n   */\n\n\n  isSingle() {\n    return !this._selectElement.hasAttribute(\"multiple\");\n  }\n  /**\r\n   * @param {string} text\r\n   * @param {string} value\r\n   * @returns {boolean}\r\n   */\n\n\n  canAdd(text, value = null) {\n    if (!value) {\n      value = text;\n    } // Check invalid input\n\n\n    if (!text) {\n      return false;\n    } // Check disabled\n\n\n    if (this.isDisabled()) {\n      return false;\n    } // Check already selected input (single will replace)\n\n\n    if (!this.isSingle() && this._isSelected(text)) {\n      return false;\n    } // Check for max\n\n\n    if (this.max && this.getSelectedValues().length >= this.max) {\n      return false;\n    } // Check for regex\n\n\n    if (this.validationRegex && !this._validateRegex(text)) {\n      this._holderElement.classList.add(\"is-invalid\");\n\n      return false;\n    }\n\n    return true;\n  }\n  /**\r\n   * You might want to use canAdd before to ensure the item is valid\r\n   * @param {string} text\r\n   * @param {string} value\r\n   * @param {object} data\r\n   */\n\n\n  addItem(text, value = null, data = {}) {\n    if (!value) {\n      value = text;\n    } // Single items remove first\n\n\n    if (this.isSingle() && this.getSelectedValues().length) {\n      this.removeLastItem(true);\n    }\n\n    const bver = this._getBootstrapVersion();\n\n    let opt = this._selectElement.querySelector('option[value=\"' + value + '\"]');\n\n    if (opt) {\n      data = opt.dataset;\n    } // create span\n\n\n    let html = text;\n    let span = document.createElement(\"span\");\n    let classes = [\"badge\"];\n    let badgeStyle = this.badgeStyle;\n\n    if (data.badgeStyle) {\n      badgeStyle = data.badgeStyle;\n    }\n\n    if (data.badgeClass) {\n      classes.push(...data.badgeClass.split(\" \"));\n    }\n\n    if (bver === 5) {\n      //https://getbootstrap.com/docs/5.1/components/badge/\n      classes = [...classes, ...[\"me-2\", \"bg-\" + badgeStyle, \"mw-100\"]];\n    } else {\n      // https://getbootstrap.com/docs/4.6/components/badge/\n      classes = [...classes, ...[\"mr-2\", \"badge-\" + badgeStyle]];\n    }\n\n    span.classList.add(...classes);\n    span.setAttribute(VALUE_ATTRIBUTE, value);\n\n    if (this.allowClear) {\n      const closeClass = classes.includes(\"text-dark\") ? \"btn-close\" : \"btn-close-white\";\n      const btn = bver === 5 ? '<button type=\"button\" style=\"font-size:0.65em\" class=\"me-2 float-start btn-close ' + closeClass + '\" aria-label=\"' + this.clearLabel + '\"></button>' : '<button type=\"button\" style=\"font-size:1em;float:left;text-shadow:none;color:currentColor;transform:scale(1.2)\" class=\"mr-2 close\" aria-label=\"' + this.clearLabel + '\"><span aria-hidden=\"true\">&times;</span></button>';\n      html = btn + html;\n    }\n\n    span.innerHTML = html;\n\n    this._containerElement.insertBefore(span, this._searchInput);\n\n    if (this.allowClear) {\n      span.querySelector(\"button\").addEventListener(\"click\", event => {\n        event.preventDefault();\n        event.stopPropagation();\n\n        if (!this.isDisabled()) {\n          this.removeItem(value);\n          document.activeElement.blur();\n\n          this._adjustWidth();\n        }\n      });\n    } // we need to create a new option\n\n\n    if (!opt) {\n      opt = document.createElement(\"option\");\n      opt.value = value;\n      opt.textContent = text; // innerText is not well supported by jsdom\n      // Pass along data provided\n\n      for (const _ref3 of Object.entries(data)) {\n        var _ref4 = _slicedToArray(_ref3, 2);\n\n        const key = _ref4[0];\n        const value = _ref4[1];\n        opt.dataset[key] = value;\n      }\n\n      this._selectElement.appendChild(opt);\n    } // update select, we need to set attribute for option[selected]\n\n\n    opt.setAttribute(\"selected\", \"selected\");\n    opt.selected = true; // Fire change event\n\n    if (this._fireEvents) {\n      this._selectElement.dispatchEvent(new Event(\"change\", {\n        bubbles: true\n      }));\n    }\n  }\n  /**\r\n   * @param {string} value\r\n   * @param {boolean} value\r\n   */\n\n\n  removeItem(value, noEvents = false) {\n    let item = this._containerElement.querySelector(\"span[\" + VALUE_ATTRIBUTE + '=\"' + value + '\"]');\n\n    if (!item) {\n      return;\n    }\n\n    item.remove(); // update select\n\n    let opt = this._selectElement.querySelector('option[value=\"' + value + '\"]');\n\n    if (opt) {\n      opt.removeAttribute(\"selected\");\n      opt.selected = false; // Fire change event\n\n      if (this._fireEvents && !noEvents) {\n        this._selectElement.dispatchEvent(new Event(\"change\", {\n          bubbles: true\n        }));\n      }\n    } // Make input visible\n\n\n    if (this._searchInput.style.visibility == \"hidden\" && this.max && this.getSelectedValues().length < this.max) {\n      this._searchInput.style.visibility = \"visible\";\n    }\n  }\n\n}\n\nexport default Tags;","map":null,"metadata":{},"sourceType":"module"}